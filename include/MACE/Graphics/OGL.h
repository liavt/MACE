/*
The MIT License (MIT)

Copyright (c) 2016 Liav Turkia

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/
#pragma once
#ifndef MACE_GRAPHICS_OGL_H
#define MACE_GRAPHICS_OGL_H

#include <MACE/System/Constants.h>
#include <MACE/Utility/Vector.h>
#include <MACE/Utility/Matrix.h>
#include <MACE/Utility/Color.h>

#include <GL/glew.h>

#include <unordered_map>
#include <vector>


namespace mc {
	namespace gfx {

		/**
		Contains various abstractions for OpenGL. Assume that any class in this namespace requires an OpenGL context.
		<p>
		OpenGL abstractions will only implement functionality from OpenGL 3.3, as that is what MACE supports.
		<p>
		Most of the abstractions have very minimal extra work. Most of the time they are direct bindings to the 
		actual OpenGL function. However, some classes like `ShaderProgram` do a lot of bookkeeping to make it easier 
		to use.
		<p>
		The documentation for classes in the `ogl` namespace assumes that you understand the underlying OpenGL concepts.
		A link to a page about the OpenGL concept is usually present.
		<p>
		Each abstraction follows a very similar syntax and style to make it easier to understand.
		@see Object
		@see Buffer
		@todo create a ReadableBuffer class with functions like glReadPixels
		*/
		namespace ogl {

			using GLError = Exception;

			using ShaderError = Exception;

			/**
			@opengl
			*/
			void checkGLError(const Index line = 0, const char* file = "Unknown file");
			/**
			@copydoc ogl::checkGLError(const Index, const char*)
			*/
			void checkGLError(const Index line, const std::string& file);

			/**
			Represents a OpenGL object in memory. All abstractions for OpenGL objects override this.
			<p>
			Due to how the OpenGL model works, using an OpenGL function outside of a thread with a context will throw an error. Thus,
			this class does not follow the RAII model.
			<p>
			A subclass of `Object` will observe the following rules:
			- The constructor and destructor will do nothing, as there is no guarantee that the `Object` will be declared in a OpenGL thread.
			- The init() and destroy() functions must be called in an OpenGL thread and will call the coressponding glCreate* and glDestroy* functions
			- The bind() and unbind() functions must be called in an OpenGL thread and will call the coressponding glBind* functions.
			- It will have an ID generated by glCreate\* and be deleted in glDelete\*.
			- bind() will use the ID created by glCreate\* and no other
			- isCreated() has to be called in an OpenGL thread
			- It will override == and !=

			@see Buffer
			@see https://www.opengl.org/wiki/OpenGL_Object
			@todo create an RAII wrapper which calls init() and destroy() automatically
			@todo store what object is currently bound. static Object getBoundObject(), bool isBound()
			*/
			class Object {
			public:
				/**
				Virtual destructor for subclasses and safety
				*/
				virtual ~Object() = default;

				/**
				Calls the corresponding glCreate\* function and assigns an ID.
				@opengl
				@see Object::destroy()
				@see Object::bind() const
				@see Object::unbind const
				@see Object::isCreated() const
				*/
				virtual void init() = 0;
				/**
				Calls the corresponding glDestroy\* function and deletes the ID.
				@opengl
				@see Object::init()
				@see Object::bind() const
				@see Object::unbind const
				@see Object::isCreated() const
				@throws GL_INVALID_OPERATION If this `Object` has not been created yet (Object::init() has not been called)
				*/
				virtual void destroy() = 0;

				/**
				Binds this `Object` to be used in an OpenGL function.
				@opengl
				@see Object::unbind() const
				@throws GL_INVALID_OPERATION If this `Object` has not been created yet
				*/
				virtual void bind() const;
				/**
				Unbinds this `Object` which is equivalent to binding ID 0.
				@opengl
				@see Object::bind() const
				*/
				virtual void unbind() const;

				/**
				Queries OpenGL whether this Object's ID is a valid object.
				@return Whether this `Object` represents memory
				@see Object::bind() const
				@see Object::init()
				@opengl
				*/
				virtual bool isCreated() const = 0;

				/**
				Retrieves the current ID that this `Object` represents.
				<p>
				The ID is an unsigned number that acts like a pointer to OpenGL memory. It is assigned when Object::init() is called.
				<p>
				If it is 0, the `Object` is considered uncreated.
				<p>
				When using Object::bind() const it will bind to this ID. Object::unbind() const will bind to ID 0, which is the equivelant of a null pointer.
				@return The ID represented by this `Object`
				*/
				Index getID() const;

				/**
				Compares if 2 `Objects` are equal.
				@see Object::getID() const
				@see Object::operator!=(const Object&) const
				@return Whether `this` and `other` are the same
				@param other What to compare with
				*/
				bool operator==(const Object& other) const;
				/**
				Compares if 2 `Objects` are not equal.
				@see Object::getID() const
				@see Object::operator==(const Object&) const
				@return Whether `this` and `other` are different
				@param other What to compare with
				*/
				bool operator!=(const Object& other) const;
			protected:
				/**
				The ID of this `Object.` Should be set in Object::init() and become 0 in Object::destroy()
				<p>
				Object::getID() const returns this.
				*/
				Index id = 0;

				/**
				Intended to be overloaded to bind to a certain index. Object::bind() const and Object::unbind() const both use this function.
				@param id Index to bind to. If it is 0, it needs to be unbinded.
				@opengl
				@internal
				*/
				virtual void bindIndex(const Index id) const = 0;
			};

			/**
			Special object that is used for asynchronous queries of information from the GPU.
			<p>
			Even though it extends `Object` it does not implement the Object::bind() const or `unbind()` functions.
			Instead, the `QueryObject` uses the QueryObject::begin(const Enum) and QueryObject::end(const Enum)
			functions.
			@see https://www.opengl.org/wiki/Query_Object
			*/
			class QueryObject: public Object {
			public:
				/**
				This `QueryObject` will begin querying data for a specified target.
				<p>
				Replacement for the Object::bind() const function.
				<p>
				The results can be queried with one of the `QueryObject::get` funcitons.
				@param target THe kind of data to query. Can not be GL_TIMESTAMP.
				@see https://www.opengl.org/wiki/GLAPI/glBeginQuery
				@see QueryObject::counter()
				@attention When you use this function make sure to also call QueryObject::end(const Enum) eventually
				@opengl
				*/
				void begin(const Enum target);
				/**
				Stops querying data for a certain target.
				<p>
				Replacement for the Object::unbind() const function
				<p>
				The results can be queried with one of the `QueryObject::get` funcitons.
				@param target The kind of data being queried. Can not be GL_TIMESTAMP
				@see https://www.opengl.org/wiki/GLAPI/glBeginQuery
				@throws GL_INVALID_OPERATION If QueryObject::begin(const Enum was never called)
				@opengl
				*/
				void end(const Enum target);

				/**
				Retrieves data from a begin/end pair.
				@param name The name of the results you want to retrieve. Must be GL_QUERY_RESULT, GL_QUERY_RESULT_NO_WAIT​, or GL_QUERY_RESULT_AVAILABLE
				@param data Where to put the data into.
				@see QueryObject::begin(const Enum)
				@see QueryObject::end(const Enum)
				@see QueryObject::counter()
				@see https://www.opengl.org/wiki/GLAPI/glGetQueryObject
				@opengl
				*/
				void get(const Enum name, int* data) const;

				/**
				@copydoc get(const Enum, int* data) const
				*/
				void get(const Enum name, unsigned int* data) const;

				/**
				@copydoc get(const Enum, int* data) const
				*/
				void get(const Enum name, int64_t* data) const;
				/**
				@copydoc get(const Enum, int* data) const
				*/
				void get(const Enum name, uint64_t* data) const;

				/**
				Records the current GPU time into this `QueryObject.` This returns immediately.
				<p>
				Can be used in conjunction with QueryObject::begin(const Enum) with a target of
				`GL_TIME_ELAPSED`
				@see QueryObject::end(const Enum)
				@see QueryObject::get(const Enum, uint64_t*) const
				@see https://www.opengl.org/wiki/GLAPI/glQueryCounter
				@opengl
				*/
				void counter();

				void init() final;
				void destroy() final;

				bool isCreated() const final;

				using Object::operator==;
				using Object::operator!=;

			private:
				//queryobjects cant be bound or unbound according to the opengl spec
				void bind() const final;
				void unbind() const final;

				void bindIndex(const Index id) const final;
			};//QueryObject

			/**
			Represents a render buffer for use with a `FrameBuffer.` Instead of using a `Texture` target, you can attach a `RenderBuffer` instead
			and accomplish a similar effect. A `RenderBuffer` supports anti-aliasing natively but you can not access or modify it's data. It also
			represents a single image, similar to a texture.
			@see FrameBuffer
			@see https://www.opengl.org/wiki/Renderbuffer_Object
			*/
			class RenderBuffer: public Object {
			public:
				void init() override;
				void destroy() override;

				/**
				Sets the flags for the storage of this `RenderBuffer.`
				@param format A valied OpenGL image format such as GL_RGBA8
				@param width The width of the buffer
				@param height The height of the buffer
				@see RenderBuffer::setStorageMultisampled(const Size, const Enum, const Size, const Size)
				@see https://www.opengl.org/wiki/GLAPI/glRenderbufferStorage
				@opengl
				*/
				void setStorage(const Enum format, const Size width, const Size height);
				/**
				Sets the flags for the storage of this `RenderBuffer.` This version can have anti-aliasing.
				@param samples How many samples to use for MSAA
				@param format A valied OpenGL image format such as GL_RGBA8
				@param width The width of the buffer
				@param height The height of the buffer
				@see RenderBuffer::setStorage(const Enum, const Size, const Size)
				@see https://www.opengl.org/wiki/GLAPI/glRenderbufferStorageMultisample
				@opengl
				*/
				void setStorageMultisampled(const Size samples, const Enum format, const Size width, const Size height);

				bool isCreated() const override;

				using Object::operator==;
				using Object::operator!=;
			private:
				void bindIndex(const Index id) const override;
			};//RenderBuffer

			/**
			Represents an OpenGL Framebuffer Object which allows rendering to a non-screen location. This also allows
			rendering to a `Texture` or `RenderBuffer` object.
			<p>
			This is not a subclass of the `Buffer` object as this is technically not an OpenGL buffer. The name is
			misleading.

			@see https://www.opengl.org/wiki/Framebuffer_Object
			@see RenderBuffer
			@see Texture
			@todo target variable which is GL_FRAMEBUFFER by default. and update documentation accordingly
			*/
			class FrameBuffer: public Object {
			public:
				void init() override;
				void destroy() override;

				/**
				Attaches a texture to this `FrameBuffer`
				@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
				@param attachment Which attachment port to use.
				@param textureID ID for the `Texture` to attach. See Texture::getID() const
				@param level Mipmap level to attach. Is 0 by default.
				@see https://www.opengl.org/wiki/GLAPI/glFramebufferTexture
				@see setDrawBuffers(const Size, const Enum*)
				@todo Replace this with the actual Texture class
				@opengl
				*/
				void attachTexture(const Enum target, const Enum attachment, const unsigned int textureID, const int level = 0);
				/**
				@copydoc FrameBuffer::attachTexture(const Enum, const Enum, const unsigned int, const int)
				@param texTarget Target for the texture. If it is a cubemap, it must have a special target as specified in the OpenGL wiki link.
				*/
				void attachTexture1D(const Enum target, const Enum attachment, const Enum texTarget, const unsigned int textureID, const int level = 0);
				/**
				@copydoc FrameBuffer::attachTexture1D(const Enum, const Enum, const Enum, const unsigned int, const int)
				*/
				void attachTexture2D(const Enum target, const Enum attachment, const Enum texTarget, const unsigned int textureID, const int level = 0);
				/**
				@copydoc FrameBuffer::attachTexture1D(const Enum, const Enum, const Enum, const unsigned int, const int)
				@param layer Which layer of the 3-dimensional image to use. It is 0 by default.
				*/
				void attachTexture3D(const Enum target, const Enum attachment, const Enum texTarget, const unsigned int textureID, const int level = 0, const int layer = 0);

				/**
				Attaches a single layer from a texture to this `FrameBuffer`
				@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
				@param attachment Which attachment port to use.
				@param texture ID for the `Texture` to attach. See Texture::getID() const
				@param level Mipmap level to attach. Is 0 by default.
				@param layer Which layer of the texture to use. It is 0 by default.
				@see https://www.opengl.org/wiki/GLAPI/glFramebufferTextureLayer
				@opengl
				*/
				void attachTextureLayer(const Enum target, const Enum attachment, const unsigned int texture, const int level = 0, const int layer = 0);

				/**
				Attaches a `RenderBuffer` to this `FrameBuffer` for rendering.
				@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
				@param attachment Which attachment port to use
				@param buffer The `RenderBuffer` to use.
				@see https://www.opengl.org/wiki/GLAPI/glFramebufferRenderbuffer
				*/
				void attachRenderbuffer(const Enum target, const Enum attachment, const RenderBuffer& buffer);

				/**
				Specifies what buffers to render to. Takes in an array of attachments. A `RenderBuffer` or `Texture` can be attached to act
				as a draw buffer.
				@param arrSize Size of the array of render buffers
				@param buffers Pointer to the first element of the array
				@see https://www.opengl.org/wiki/GLAPI/glDrawBuffers
				@see FrameBuffer::attachTexture(const Enum, const Enum, const Enum, const unsigned int)
				@see FrameBuffer::attachTexture1D(const Enum, const Enum, const Enum, const unsigned int, const int)
				@see FrameBuffer::attachTexture2D(const Enum, const Enum, const Enum, const unsigned int, const int)
				@see FrameBuffer::attachTexture2D(const Enum, const Enum, const Enum, const unsigned int, const int, const int)
				@see FrameBuffer::attachTextureLayer(const Enum, const Enum, const unsigned int, const int)
				@see FrameBuffer::attachRenderbuffer(const Enum, const Enum, const RenderBuffer&)
				@opengl
				*/
				void setDrawBuffers(const Size arrSize, const Enum* buffers);

				/**
				Select which color buffer to use for reading via
				FrameBuffer::readPixels(const int, const int, const Size, const Size, const Enum, const Enum, void*) const

				@param mode Which attachment to use
				@see FrameBuffer::setPixelStore(const Enum, const float)
				@see https://www.opengl.org/sdk/docs/man/html/glReadBuffer.xhtml
				@see FrameBuffer::attachTexture(const Enum, const Enum, const Enum, const unsigned int)
				@see FrameBuffer::attachTexture1D(const Enum, const Enum, const Enum, const unsigned int, const int)
				@see FrameBuffer::attachTexture2D(const Enum, const Enum, const Enum, const unsigned int, const int)
				@see FrameBuffer::attachTexture2D(const Enum, const Enum, const Enum, const unsigned int, const int, const int)
				@see FrameBuffer::attachTextureLayer(const Enum, const Enum, const unsigned int, const int)
				@see FrameBuffer::attachRenderbuffer(const Enum, const Enum, const RenderBuffer&)
				@opengl
				*/
				void setReadBuffer(const Enum mode);

				/**
				Read pixels from this `FrameBuffer`

				@param x The x-coordinate of the lower-left pixel block you want to read. The origin is the lower left corner of the framebuffer
				@param y The y-coordinate of the lower-left pixel block you want to read. The origin is the lower left corner of the framebuffer
				@param width The width of the pixel block you want to read. A width and height of 1 means a single pixel
				@param height The height of the pixel block you want to read. A width and height of 1 means a single pixel
				@param format The format of the pixel data. Must be one of GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
				@param type The type of the pixel data
				@param data Pointer to where you want the data to be written to.
				@see https://www.opengl.org/sdk/docs/man/html/glReadPixels.xhtml
				@see FrameBuffer::setPixelStore(const Enum, const float)
				@see FrameBuffer::setReadBuffer(const Enum);
				@opengl
				*/
				void readPixels(const int x, const int y, const Size width, const Size height, const Enum format, const Enum type, void* data) const;

				/**
				Set the pixel storage mode for this `FrameBuffer` for use in
				FrameBuffer::readPixels(const int, const int, const Size, const Size, const Enum, const Enum, void*) const

				@param name The parameter to change
				@param param What to change it to
				@see https://www.opengl.org/sdk/docs/man/html/glPixelStore.xhtml
				@see
				@opengl
				*/
				void setPixelStore(const Enum name, const float param);
				/**
				@copydoc setPixelStore(const Enum, const float)
				*/
				void setPixelStore(const Enum name, const int param);

				bool isCreated() const override;

				/**
				Queries OpenGL for the status of this `FrameBuffer.` Can be used to detect whether this `FrameBuffer` encountered an error
				during creation.
				@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
				@return The `FrameBuffer` status. The full list of enums is described in the OpenGL specification.
				@see https://www.opengl.org/wiki/GLAPI/glCheckFramebufferStatus
				@opengl
				*/
				Enum checkStatus(const Enum target);

				using Object::operator==;
				using Object::operator!=;
			private:
				void bindIndex(const Index id) const override;
			};//FrameBuffer

			/**
			@see https://www.opengl.org/wiki/Texture
			*/
			class Texture: public Object {
			public:
				Texture() noexcept;
				/**
				@opengl
				*/
				Texture(const Color& col);
				Texture(const Texture& other, const Color& color);
				/**
				@opengl
				*/
				Texture(const char* file);
				/**
				@opengl
				*/
				Texture(const std::string& file);

				void init() override;
				void destroy() override;

				/**
				@see https://www.opengl.org/wiki/GLAPI/glTexImage2D
				@opengl
				*/
				void setData(const void * data, const Size width, const Size height, const Enum type = GL_FLOAT, const Enum format = GL_RGB, const Enum internalFormat = GL_RGB, const Index mipmapLevel = 0);

				/**
				@opengl
				*/
				void loadFile(const char* file);
				/**
				@copydoc loadFile(const char*)
				*/
				void loadFile(const std::string& file);

				void generateMipmap();

				void setTarget(const Enum target);
				Enum getTarget();

				Color& getPaint();
				const Color& getPaint() const;
				void setPaint(const Color& c);

				float getOpacity();
				const float getOpacity() const;
				void setOpacity(const float f);

				bool isCreated() const override;

				/**
				@see https://www.opengl.org/wiki/GLAPI/glTexParameter
				@opengl
				*/
				void setParameter(const Enum name, const int value);

				/**
				@copydoc Object::operator==(const Object&) const
				*/
				bool operator==(const Texture& other) const;
				/**
				@copydoc Object::operator!=(const Object&) const
				*/
				bool operator!=(const Texture& other) const;

			private:
				Enum target = GL_TEXTURE_2D;

				Color paint = Color(1.0f, 1.0f, 1.0f, 1.0f);

				float opacity = 1.0f;

				void bindIndex(const Index id) const override;
			};//Texture

			/**
			Represents a buffer of memory in the GPU. This class should not be used directly. Instead,
			use special subclasses which provide additional functionality for the specific buffer type.

			@see RenderBuffer
			@see FrameBuffer
			@see VertexBuffer
			@see UniformBuffer
			@see ElementBuffer
			*/
			class Buffer: public Object {
			public:
				virtual ~Buffer() = default;

				/**
				Creates the buffer with the specified buffer type. You should not usually use this directly.
				Instead, use a subclass which has extra functions for the buffer type.
				<p>
				For example, instead of creating a `Buffer` with the type of `GL_ARRAY_BUFFER`, use the
				`VertexBuffer` class.

				@internal
				@see RenderBuffer
				@see FrameBuffer
				@see Texture
				@see VertexBuffer
				@see UniformBuffer
				@param bufferType OpenGL symbolic constant with the desired type.
				*/
				Buffer(const Enum bufferType) noexcept;

				bool isCreated() const override;

				void init() override;
				void destroy() override;

				/**
				Creates and initalizes the data store for this `Buffer`

				@param dataSize Size of the buffer, measured in bytes.
				@param data Pointer to the actual data. Using `nullptr` or `NULL` will create an empty buffer.
				@param drawType Expected usage pattern for the data. GL_DYNAMIC_DRAW by default
				@see Buffer::setDataRange(const Index, const ptrdiff_t, const void*)
				@see Buffer::copyData(Buffer&, const ptrdiff_t&, const Index, const Index)
				@see https://www.opengl.org/wiki/GLAPI/glBufferData
				@opengl
				*/
				void setData(const ptrdiff_t& dataSize, const void* data, const Enum drawType = GL_DYNAMIC_DRAW);
				/**
				Sets data in a range of the buffer.
				<p>
				Does not initialize data. Buffer:setData(const ptrdiff_t&, const void*, const Enum) must be called first.
				@param offset Offset into the buffer to set the data, measured in bytes
				@param dataSize How large the region being inserted is, measured in bytes
				@param data Pointer to the data being inserted
				@see https://www.opengl.org/wiki/GLAPI/glBufferSubData
				@see Buffer::copyData(Buffer&, const ptrdiff_t&, const Index, const Index)
				@opengl
				*/
				void setDataRange(const Index offset, const ptrdiff_t& dataSize, const void* data);

				/**
				Copy part of the data store of this `Buffer` into another `Buffer`

				@param other Target `Buffer` to copy into
				@param size How much data to copy
				@param readOffset How much data to offset by in this `Buffer`
				@param writeOffset Where to write the data in the target `Buffer`
				@see Buffer::setData(const ptrdiff_t&, const void*, const Enum)
				@see https://www.opengl.org/wiki/GLAPI/glCopyBufferSubData
				@see CopyReadBuffer
				@see CopyWriteBuffer
				@opengl
				*/
				void copyData(Buffer& other, const ptrdiff_t& size, const Index readOffset = 0, const Index writeOffset = 0);

				/**
				Maps the data in this `Buffer` to a pointer on the CPU side. May be slow.

				@param access Which access to use. Must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
				@see https://www.opengl.org/wiki/GLAPI/glMapBuffer
				@see Buffer::mapRange(const Index, const Size, const unsigned int)
				@warning DO NOT DELETE THE POINTER RETURNED. IT IS NOT DYNAMICALLY ALLOCATED.
				@warning After Buffer::unmap() is called, the pointer returned may be unsafe. Using it will be undefined.
				@attention When using this function don't forget to use Buffer::unmap() when you are done using the pointer
				@opengl
				*/
				void* map(const Enum access = GL_READ_WRITE);

				/**
				Maps a range of data in this `Buffer` to a pointer on the CPU side.

				@param offset The starting offset to map
				@param length How much data to map
				@param access A combination of access flags to determine how the data will be used. These flags determine how fast or slow the mapping will take.
				@see https://www.opengl.org/wiki/GLAPI/glMapBufferRange
				@see Buffer::map(const Enum)
				@warning DO NOT DELETE THE POINTER RETURNED. IT IS NOT DYNAMICALLY ALLOCATED.
				@warning After Buffer::unmap() is called, the pointer returned may be unsafe. Using it will be undefined.
				@attention When using this function don't forget to use Buffer::unmap() when you are done using the pointer
				@opengl
				*/
				void* mapRange(const Index offset, const Size length, const unsigned int access);

				/**
				Unmaps the buffer. Any mapped points will be deleted and using them will be undefined.

				@return Whether the data was corrupted during reading. This will be very rare but when it does happen you must reinitialize the data.
				@see Buffer::map(const Enum)
				@see Buffer::mapRange(const Index, const Size, const unsigned int)
				@see https://www.opengl.org/wiki/GLAPI/glMapBuffer
				@warning Using a pointer after it was unmapped will be undefined
				@opengl
				*/
				bool unmap();

				/**
				Retrieves the buffer type for this buffer. This is based on the class.
				@return The buffer type
				*/
				const Enum getBufferType() const;

				/**
				@copydoc Object::operator==(const Object&) const
				*/
				bool operator==(const Buffer& other) const;
				/**
				@copydoc Object::operator!=(const Object&) const
				*/
				bool operator!=(const Buffer& other) const;
			private:
				Enum bufferType;

				void bindIndex(const Index id) const override;
			};//Buffer

			/**
			Special buffer that excels at asynchronous pixel transfer operations. The `PixelUnpackBuffer` is fast at reading
			pixels while the `PixelPackBuffer` is fast at writing pixels.
			<p>
			Not to be confused with a `FrameBuffer` or `Texture.`
			@see https://www.opengl.org/wiki/Pixel_Buffer_Object
			*/
			class PixelUnpackBuffer: public Buffer {
			public:
				PixelUnpackBuffer() noexcept;

				using Buffer::operator==;
				using Buffer::operator!=;
			};//PixelUnpackBuffer

			/**
			@copydoc PixelUnpackBuffer
			*/
			class PixelPackBuffer: public Buffer {
			public:
				PixelPackBuffer() noexcept;

				using Buffer::operator==;
				using Buffer::operator!=;
			};//PixelPackBuffer

			/**
			Stores vertex data for a `VertexArray.` This is absolutely crucial for any rendering in `OpenGL.`
			<p>
			A `VertexArray` is simply an array of `VertexBuffer` behind the scenes. It provides an easy way
			to have multiple sets of data for one rendering pass, such as colors, texture coordinates, and
			normals.
			@see https://www.opengl.org/wiki/Vertex_Specification::Vertex_Buffer_Object
			*/
			class VertexBuffer: public Buffer {
			public:
				VertexBuffer() noexcept;

				/**
				Tells OpenGL how to interpret array data. Must be called in order for rendering to work. Must be used in
				conjuction with Buffer::setData(const ptrdiff_t, const GLvoid*, const Enum)
				<p>
				Behind the scenes, it will call either `glVertexAttribPointer` or `glVertexAttribIPointer` based on the
				arguments provided.
				@param attribSize The size of the component. Must be 1,2,3,4 or GL_BGRA (which is 4.)
				@param type The data type of the component, like GL_FLOAT or GL_UNSIGNED_INT
				@param normalized Whether the data should be normalized to a float or keep the initial value. False by default.
				@param stride The offset between components. 0 means every component is tightly packed. 0 by default.
				@param pointer An offset of the first component. 0 by default.
				@see https://www.opengl.org/wiki/GLAPI/glVertexAttribPointer
				@see VertexArray
				@opengl
				*/
				void setAttributePointer(const Byte& attribSize, const Enum type, const bool& normalized = 0, const Index stride = 0, const void* pointer = nullptr);

				/**
				Modify the rate at which vertex attribute advance during instancing. If instanced rendering is not being used,
				this function does nothing.
				@param divisor The rate at which it moves through the data in rendering
				@see https://www.opengl.org/wiki/GLAPI/glVertexAttribDivisor
				@opengl
				@*/
				void setDivisor(const unsigned int divisor);

				/**
				Enables this `VertexBuffer` for use in rendering. Not to be confused with Object::bind() const which binds
				data for modification or reading.
				@see https://www.opengl.org/wiki/GLAPI/glEnableVertexAttribArray
				@see VertexBuffer::disable() const
				@opengl
				*/
				void enable() const;
				/**
				Disable this `VertexBuffer` for use in rendering. Not to be confused with Object::unbind() const which unbinds
				data for modification or reading.
				@see https://www.opengl.org/wiki/GLAPI/glEnableVertexAttribArray
				@see VertexBuffer::enable() const
				@opengl
				*/
				void disable() const;

				/**
				Gets the current attribute location of this `VertexBuffer`
				@return The attribute index
				*/
				Index getLocation();
				/**
				@copydoc VertexBuffer::getLocation()
				*/
				const Index getLocation() const;
				/**
				Sets the attribute location of this `VertexBuffer.` 0 by default.
				@param newLocation What to set it to
				*/
				void setLocation(const Index newLocation);

				/**
				@copydoc Object::operator==(const Object&) const
				*/
				bool operator==(const VertexBuffer& other) const;
				/**
				@copydoc Object::operator!=(const Object&) const
				*/
				bool operator!=(const VertexBuffer& other) const;
			private:
				Index location = 0;
			};//VertexBuffer

			/**
			Stores element indices to save vertex data.

			@see https://www.opengl.org/wiki/Vertex_Specification::Index_buffers
			@see https://www.opengl.org/wiki/GLAPI/glDrawElements
			@see VertexArray
			@see VertexBuffer
			@note You must use the ElementBuffer::setIndiceNumber(const Size) function for this class to work correctly.
			*/
			class ElementBuffer: public Buffer {
			public:
				ElementBuffer() noexcept;

				/**
				Constructs an `ElementBuffer` with a specified amount of indices. Analagous to calling ElementBuffer::setIndiceNumber(const Size)
				immediately after construction.
				@param indiceNum The amount of indices this `ElementBuffer` will have
				@see https://www.opengl.org/wiki/GLAPI/glDrawElements
				@see https://www.opengl.org/wiki/Vertex_Rendering#Basic_Drawing
				@see ElementBuffer::getIndiceNumber()
				@see VertexArray
				*/
				ElementBuffer(const Size indiceNum) noexcept;

				/**
				Tell this `ElementBuffer` how many indices there are. This is required for proper usage in the `VertexArray` class.
				@see https://www.opengl.org/wiki/GLAPI/glDrawElements
				@see https://www.opengl.org/wiki/Vertex_Rendering#Basic_Drawing
				@see Buffer::setData(const ptrdiff_t&, const void*, const Enum)
				@see VertexArray
				@param indices The amount of indices loaded
				*/
				void setIndiceNumber(const Size indices);
				/**
				Retrieves how many indices this `ElementBuffer` has.
				@see ElementBuffer::setIndiceNumber(const Size)
				@see VertexArray
				@see https://www.opengl.org/wiki/GLAPI/glDrawElements
				@see https://www.opengl.org/wiki/Vertex_Rendering#Basic_Drawing
				@return The amount of indices
				*/
				Size getIndiceNumber();
				/**
				@copydoc ElementBuffer::getIndiceNumber()
				*/
				const Size getIndiceNumber() const;

				/**
				@copydoc Object::operator==(const Object&) const
				*/
				bool operator==(const ElementBuffer& other) const;
				/**
				@copydoc Object::operator!=(const Object&) const
				*/
				bool operator!=(const ElementBuffer& other) const;
			private:
				Size indiceNumber;
			};//ElementBuffer

			/**
			@see https://www.opengl.org/wiki/Vertex_Specification#Vertex_Array_Object
			@see VertexBuffer
			*/
			class VertexArray: public Object {
			public:
				void init() override;
				void destroy() override;

				bool isCreated() const override;

				/**
				@see https://www.opengl.org/wiki/GLAPI/glDrawElements
				@opengl
				*/
				void draw(const Enum type = GL_TRIANGLES) const;

				/**
				@opengl
				@see VertexBuffer
				*/
				void loadVertices(const Size& verticeSize, const GLfloat vertices[], const Index& location = 15, const Size& attributeSize = 3);
				/**
				@opengl
				@see VertexBuffer
				*/
				void loadIndices(const Size indiceNum, const unsigned int* indiceData);

				/**
				@opengl
				@see VertexBuffer
				*/
				void storeDataInAttributeList(const Size& dataSize, const GLvoid* data, const Index& location = 0, const Size& attributeSize = 3);

				/**
				@opengl
				*/
				void addBuffer(const VertexBuffer& newBuffer);

				void setVertexNumber(const Size vertexNum);
				Size getVertexNumber();
				const Size getVertexNumber() const;

				void setIndices(const ElementBuffer& buffer);
				ElementBuffer& getIndices();
				const ElementBuffer& getIndices() const;

				void setBuffers(const std::vector<VertexBuffer>& newBuffers);
				std::vector<VertexBuffer>& getBuffers();
				const std::vector<VertexBuffer>& getBuffers() const;

				/**
				@copydoc Object::operator==(const Object&) const
				*/
				bool operator==(const VertexArray& other) const;
				/**
				@copydoc Object::operator!=(const Object&) const
				*/
				bool operator!=(const VertexArray& other) const;
			private:
				void bindIndex(const Index id) const override;

				ElementBuffer indices;
				std::vector<VertexBuffer> buffers = std::vector<VertexBuffer>();

				Size vertexNumber;
			};//VertexArray

			/**
			Special buffer with no extra semantics to be used as a proxy in copying. Instead of using an existing buffer with data to copy data,
			this buffer can be used easily.

			@see https://www.opengl.org/wiki/Buffer_Object::Copying
			@see Buffer::copyData(Buffer, ptrdiff_t, Index, Index);
			@see CopyWriteBuffer
			@see Buffer
			*/
			class CopyReadBuffer: public Buffer {
			public:
				CopyReadBuffer() noexcept;

				using Buffer::operator==;
				using Buffer::operator!=;
			};//CopyReadBuffer

			/**
			@copydoc CopyReadBuffer
			@see CopyReadBuffer
			*/
			class CopyWriteBuffer: public Buffer {
			public:
				CopyWriteBuffer() noexcept;

				using Buffer::operator==;
				using Buffer::operator!=;
			};//CopyWriteBuffer

			/**
			Stores uniform data for a shader in the form of a buffer. Can be used to share data between multiple shaders or quickly change between
			sets of uniforms in one program.
			@see https://www.opengl.org/wiki/Uniform_Buffer_Object
			@see VertexBuffer
			*/
			class UniformBuffer: public Buffer {
			public:
				UniformBuffer() noexcept;

				/**
				Modify the location that this `UniformBuffer` is currently bound to.
				<p>
				The location is used in the UniformBuffer::bindForRender(const Index, const ptrdiff_t) const
				and UniformBuffer::bindToUniformBlock(const Index, const char*) const functions, as well as
				in the shaders.
				@param location The new location for this `UniformBuffer` object.
				*/
				void setLocation(const Index location);
				/**
				Retrieves the location that this `UniformBuffer` is currently bound to.
				@return The location
				@see UniformBuffer::setLocation(const Index)
				*/
				Index getLocation();
				/**
				@copydoc UniformBuffer::getLocation()
				*/
				const Index getLocation() const;

				/**
				Binds this `UniformBuffer` for rendering. Must be called before a rendering call is used.
				<p>
				Not to be confused with Object::bind() const
				@param offset How many components to start at in rendering. 0 by default
				@param size How many components to use in rendering
				@see https://www.opengl.org/wiki/GLAPI/glBindBufferBase
				@see https://www.opengl.org/wiki/GLAPI/glBindBufferRange
				@opengl
				*/
				void bindForRender(const Index offset = 0, const ptrdiff_t size = -1) const;

				/**
				Binds this `UniformBuffer` to a `ShaderProgram.` Must be used or else the shader won't be
				able to access the buffer data.
				@param programID The ID of the `ShaderProgram`
				@param blockName The name of the uniform block in the shader to bind to. Must be case sensitive.
				@see https://www.opengl.org/wiki/GLAPI/glUniformBlockBinding
				@opengl
				*/
				void bindToUniformBlock(const Index programID, const char* blockName) const;

				/**
				@copydoc Object::operator==(const Object&) const
				*/
				bool operator==(const UniformBuffer& other) const;
				/**
				@copydoc Object::operator!=(const Object&) const
				*/
				bool operator!=(const UniformBuffer& other) const;
			private:
				Index location = 0;
			};//UniformBuffer

			/**
			Represents a shader object in OpenGL. A shader is a special program that gets executed during different parts of rendering.
			<p>
			The `Shader` class must be used with the `ShaderProgram` class.
			<p>
			In order to work correctly, Shader::setType(const Enum) or Shader::Shader(const Enum) noexcept must be called and a type must be
			set.
			<p>
			Unlike other `Objects`, the default constructor of `Shader` should not be used. It is only implemented for compatibility reasons.
			The `type` of the shader must be set before most functions are called. If `type` is equal to `GL_FALSE` an error is thrown.
			<p>
			Even though it extends `Object` it does not implement the Object::bind() const or `unbind()` functions. Instead, add the
			shader to a `ShaderProgram` and it will link from there.
			@see https://www.opengl.org/wiki/Shader
			@see https://www.opengl.org/wiki/GLSL_Object#Program_objects
			*/
			class Shader: public Object {
			public:
				/**
				Default constructor which sets `type` to `GL_FALSE`. If a function that requires `type` to be set is called, an error
				is thrown.
				<p>
				If this constructor is used, the Shader::setType(const Enum) function should be used later to set a type.
				@see Shader::Shader(const Enum) noexcept
				@see Shader
				*/
				Shader() noexcept;
				/**
				Constructor which sets the type of the `Shader`. Should be used instead of `Shader::Shader() noexcept`
				<p>
				The `type` must be a valid OpenGL constant representing a type of shader. If it is incorrect, an
				`OpenGLError` is thrown.
				@param type The type of `Shader`. Must be `GL_VERTEX_SHADER`, `GL_FRAGMENT_SHADER`, `GL_GEOMETRY_SHADER`, or the following if available: `GL_TESS_CONTROL_SHADER`, `GL_TESS_EVALUATION_SHADER`, and `GL_COMPUTE_SHADER`
				@see Shader::setType(const Enum)
				@see Shader
				*/
				Shader(const Enum type) noexcept;

				void init() override;
				void destroy() override;

				/**
				@see https://www.opengl.org/wiki/GLAPI/glShaderSource
				@opengl
				*/
				void setSource(const Size count, const char* strings[], const int lengths[]);
				void setSource(const char string[], const int length);
				void setSource(const std::string& string);

				/**
				@see https://www.opengl.org/wiki/GLAPI/glCompileShader
				*/
				void compile();

				bool isCreated() const override;

				void setType(const Enum newType);
				Enum getType();
				const Enum getType() const;

				bool operator==(const Shader& other) const;
				bool operator!=(const Shader& other) const;
			private:
				Enum type;

				//shaders cant be bound or unbound according to the opengl spec
				void bind() const final;
				void unbind() const final;

				void bindIndex(const Index id) const final;
			};//Shader

			/**
			@see https://www.opengl.org/wiki/Shader
			@see https://www.opengl.org/wiki/GLSL_Object#Program_objects
			@see Shader
			*/
			class ShaderProgram: public Object {
			public:
				void init() override;
				void destroy() override;

				/**
				@opengl
				*/
				void link();

				bool isCreated() const override;

				/**
				@opengl
				*/
				void attachShader(const Shader shader);

				/**
				@opengl
				*/
				void createFragment(const char shader[]);
				/**
				@opengl
				*/
				void createFragment(const std::string& shader);
				/**
				@opengl
				*/
				void createVertex(const char shader[]);
				/**
				@opengl
				*/
				void createVertex(const std::string& shader);
				/**
				@opengl
				*/
				void createGeometry(const char shader[]);
				/**
				@opengl
				*/
				void createGeometry(const std::string& shader);

				/**
				@opengl
				*/
				void createUniform(const std::string& name);
				/**
				@opengl
				*/
				void createUniform(const char* name);

				int getUniformLocation(const std::string& name) const;
				int getUniformLocation(const char* name) const;

				//Up next are a bunch of autogenerated overloaded functions
				//setUniform with float matrices
				/**
				@opengl
				*/
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 2, 2>& m);
				void setUniform(char * name, const mc::Matrix<float, 2, 2>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 3, 3>& m);
				void setUniform(char * name, const mc::Matrix<float, 3, 3>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 4, 4>& m);
				void setUniform(char * name, const mc::Matrix<float, 4, 4>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 2, 3>& m);
				void setUniform(char * name, const mc::Matrix<float, 2, 3>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 3, 2>& m);
				void setUniform(char * name, const mc::Matrix<float, 3, 2>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 2, 4>& m);
				void setUniform(char * name, const mc::Matrix<float, 2, 4>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 3, 4>& m);
				void setUniform(char * name, const mc::Matrix<float, 3, 4>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<float, 4, 3>& m);
				void setUniform(char * name, const mc::Matrix<float, 4, 3>& m);
				//setUniform with double matrices
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 2, 2>& m);
				void setUniform(char * name, const mc::Matrix<double, 2, 2>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 3, 3>& m);
				void setUniform(char * name, const mc::Matrix<double, 3, 3>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 4, 4>& m);
				void setUniform(char * name, const mc::Matrix<double, 4, 4>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 2, 3>& m);
				void setUniform(char * name, const mc::Matrix<double, 2, 3>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 3, 2>& m);
				void setUniform(char * name, const mc::Matrix<double, 3, 2>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 2, 4>& m);
				void setUniform(char * name, const mc::Matrix<double, 2, 4>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 3, 4>& m);
				void setUniform(char * name, const mc::Matrix<double, 3, 4>& m);
				void setUniform(char * name, const bool transpose, const mc::Matrix<double, 4, 3>& m);
				void setUniform(char * name, const mc::Matrix<double, 4, 3>& m);

				//setUniform with float
				void setUniform(char * name, const float a);
				void setUniform(char * name, const float a, const float b);
				void setUniform(char * name, const float a, const float b, const float c);
				void setUniform(char * name, const float a, const float b, const float c, const float d);
				void setUniform(char * name, const Size arraySize, const float* a);
				void setUniform(char * name, const Size componentSize, const Size arraySize, const float* a);
				void setUniform(char * name, const mc::Vector<float, 1> v);
				void setUniform(char * name, const mc::Vector<float, 2> v);
				void setUniform(char * name, const mc::Vector<float, 3> v);
				void setUniform(char * name, const mc::Vector<float, 4> v);
				//setUniform with double
				void setUniform(char * name, const double a);
				void setUniform(char * name, const double a, const double b);
				void setUniform(char * name, const double a, const double b, const double c);
				void setUniform(char * name, const double a, const double b, const double c, const double d);;
				void setUniform(char * name, const Size arraySize, const double* a);
				void setUniform(char * name, const Size componentSize, const Size arraySize, const double* a);
				void setUniform(char * name, const mc::Vector<double, 1> v);
				void setUniform(char * name, const mc::Vector<double, 2> v);
				void setUniform(char * name, const mc::Vector<double, 3> v);
				void setUniform(char * name, const mc::Vector<double, 4> v);
				//setUniform with int
				void setUniform(char * name, const int a);
				void setUniform(char * name, const int a, const int b);
				void setUniform(char * name, const int a, const int b, const int c);
				void setUniform(char * name, const int a, const int b, const int c, const int d);
				void setUniform(char * name, const Size arraySize, const int* a);
				void setUniform(char * name, const Size componentSize, const Size arraySize, const int* a);
				void setUniform(char * name, const mc::Vector<int, 1> v);
				void setUniform(char * name, const mc::Vector<int, 2> v);
				void setUniform(char * name, const mc::Vector<int, 3> v);
				void setUniform(char * name, const mc::Vector<int, 4> v);
				//setUniform with unsigned int
				void setUniform(char * name, const unsigned int a);
				void setUniform(char * name, const unsigned int a, const unsigned int b);
				void setUniform(char * name, const unsigned int a, const unsigned int b, const unsigned int c);
				void setUniform(char * name, const unsigned int a, const unsigned int b, const unsigned int c, const unsigned int d);;
				void setUniform(char * name, const Size arraySize, const unsigned int* a);
				void setUniform(char * name, const Size componentSize, const Size arraySize, const unsigned int* a);
				void setUniform(char * name, const mc::Vector<unsigned int, 1> v);
				void setUniform(char * name, const mc::Vector<unsigned int, 2> v);
				void setUniform(char * name, const mc::Vector<unsigned int, 3> v);
				void setUniform(char * name, const mc::Vector<unsigned int, 4> v);

				void setShaders(const std::unordered_map<Enum, Shader>& newShaders);
				const std::unordered_map<Enum, Shader>& getShaders() const;
				std::unordered_map<Enum, Shader>& getShaders();

				void setUniforms(const std::unordered_map<std::string, int>& newUniforms);
				const std::unordered_map<std::string, int>& getUniforms() const;
				std::unordered_map<std::string, int>& getUniforms();

				bool operator==(const ShaderProgram& other) const;
				bool operator!=(const ShaderProgram& other) const;

			private:
				std::unordered_map<Enum, Shader> shaders;
				std::unordered_map<std::string, int> uniforms;

				void bindIndex(const Index id) const override;
			};//ShaderProgram
		}
	}//gfx
}//mc

#endif