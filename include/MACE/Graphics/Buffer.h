/*
The MIT License (MIT)

Copyright (c) 2016 Liav Turkia

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
*/
#pragma once
#ifndef MACE_GRAPHICS_BUFFER_H
#define MACE_GRAPHICS_BUFFER_H

#include <MACE/System/Constants.h>
#include <MACE/Utility/Color.h>
#include <GL/glew.h>


namespace mc {
	namespace gfx {

		/**
		Represents a OpenGL object in memory. All abstractions for OpenGL objects override this. 
		<p>
		Due to how the OpenGL model works, using an OpenGL function outside of a thread with a context will throw an error. Thus,
		this class does not follow the RAII model.
		<p>
		A subclass of `Object` will observe the following rules:
		- The constructor and destructor will do nothing, as there is no guarantee that the `Object` will be declared in a OpenGL thread.
		- The init() and destroy() functions must be called in an OpenGL thread and will call the coressponding glCreate* and glDestroy* functions
		- The bind() and unbind() functions must be called in an OpenGL thread and will call the coressponding glBind* functions.
		- It will have an ID generated by glCreate\* and be deleted in glDelete\*.
		- bind() will use the ID created by glCreate\* and no other
		- isCreated() has to be called in an OpenGL thread
		- It will override == and !=
		@see Buffer
		@see https://www.opengl.org/wiki/OpenGL_Object
		*/
		class Object {
		public:
			/**
			Virtual destructor for subclasses and safety
			*/
			virtual ~Object() = default;

			/**
			Calls the corresponding glCreate\* function and assigns an ID.
			@opengl
			@see Object#destroy()
			@see Object#bind() const
			@see Object#unbind const
			@see Object#isCreated() const
			*/
			virtual void init() = 0;
			/**
			Calls the corresponding glDestroy\* function and deletes the ID.
			@opengl
			@see Object#init()
			@see Object#bind() const
			@see Object#unbind const
			@see Object#isCreated() const
			@throws GL_INVALID_OPERATION If this `Object` has not been created yet
			*/
			virtual void destroy() = 0;

			/**
			Binds this `Object` to be used in an OpenGL function.
			@opengl
			@see Object#unbind() const
			@throws GL_INVALID_OPERATION If this `Object` has not been created yet
			*/
			void bind() const;
			/**
			Unbinds this `Object` which is equivalent to binding ID 0.
			@opengl
			@see Object#bind() const
			*/
			void unbind() const;

			/**
			Queries OpenGL whether this Object's ID is a valid object.
			@return Whether this `Object` represents memory
			@see Object#bind() const
			@see Object#init()
			@opengl
			*/
			virtual bool isCreated() const = 0;

			/**
			Retrieves the current ID that this `Object` represents.
			<p>
			The ID is an unsigned number that acts like a pointer to OpenGL memory. It is assigned when Object#init() is called.
			<p>
			If it is 0, the `Object` is considered uncreated.
			<p>
			When using Object#bind() const it will bind to this ID. Object#unbind() const will bind to ID 0, which is the equivelant of a null pointer.
			@return The ID represented by this `Object`
			*/
			Index getID() const;

			/**
			Compares if 2 `Objects` are equal. Their ID is compared.
			@see Object#getID() const
			@see Object#operator!=(const Object&) const
			@return Whether `this` and `other` are the same
			@param other What to compare with
			*/
			bool operator==(const Object& other) const;
			/**
			Compares if 2 `Objects` are not equal. Their ID is compared.
			@see Object#getID() const
			@see Object#operator==(const Object&) const
			@return Whether `this` and `other` are different
			@param other What to compare with
			*/
			bool operator!=(const Object& other) const;
		protected:
			/**
			The ID of this `Object.` Should be set in Object#init() and become 0 in Object#destroy()
			<p>
			Object#getID() const returns this.
			*/
			Index id = 0;

			/**
			Intended to be overloaded to bind to a certain index. Object#bind() const and Object#unbind() const both use this function.
			@param id Index to bind to. If it is 0, it needs to be unbinded.
			@opengl
			@internal
			*/
			virtual void bindIndex(const Index& id) const = 0;
		};
		
		/**
		Represents a render buffer for use with a `FrameBuffer.` Instead of using a `Texture` target, you can attach a `RenderBuffer` instead
		and accomplish a similar effect. A `RenderBuffer` supports anti-aliasing natively but you can not access or modify it's data. It also
		represents a single image, similar to a texture.
		@see FrameBuffer
		@see https://www.opengl.org/wiki/Renderbuffer_Object
		*/
		class RenderBuffer: public Object {
		public:
			void init();
			void destroy();

			/**
			Sets the flags for the storage of this `RenderBuffer.`
			@param format A valied OpenGL image format such as GL_RGBA8
			@param width The width of the buffer
			@param height The height of the buffer
			@see RenderBuffer#setStorageMultisampled(const GLsizei&, const GLenum&, const GLsizei&, const GLsizei&)
			@see https://www.opengl.org/wiki/GLAPI/glRenderbufferStorage
			@opengl
			*/
			void setStorage(const GLenum& format, const GLsizei& width, const GLsizei& height);
			/**
			Sets the flags for the storage of this `RenderBuffer.` This version can have anti-aliasing.
			@param samples How many samples to use for MSAA
			@param format A valied OpenGL image format such as GL_RGBA8
			@param width The width of the buffer
			@param height The height of the buffer
			@see RenderBuffer#setStorage(const GLenum&, const GLsizei&, const GLsizei&)
			@see https://www.opengl.org/wiki/GLAPI/glRenderbufferStorageMultisample
			@opengl
			*/
			void setStorageMultisampled(const GLsizei& samples, const GLenum& format, const GLsizei& width, const GLsizei& height);

			bool isCreated() const;

			using Object::operator==;
			using Object::operator!=;
		private:
			void bindIndex(const Index& id) const;
		};//RenderBuffer

		/**
		Represents an OpenGL Framebuffer Object which allows rendering to a non-screen location. This also allows rendering to a `Texture` or `RenderBuffer` object.
		@see https://www.opengl.org/wiki/Framebuffer_Object
		*/
		class FrameBuffer: public Object {
		public:
			void init();
			void destroy();

			/**
			Attaches a texture to this `FrameBuffer`
			@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
			@param attachment Which attachment port to use.
			@param textureID ID for the `Texture` to attach. See Texture#getID() const
			@param level Mipmap level to attach. Is 0 by default.
			@see https://www.opengl.org/wiki/GLAPI/glFramebufferTexture
			@see setDrawBuffers(const Size&, const GLenum*)
			@todo Replace this with the actual Texture class
			@opengl
			*/
			void attachTexture(const GLenum& target, const GLenum& attachment, const GLuint& textureID, const GLint& level = 0);
			/**
			@copydoc FrameBuffer#attachTexture(const GLenum&, const GLenum&, const GLuint&, const GLint&)
			@param texTarget Target for the texture. If it is a cubemap, it must have a special target as specified in the OpenGL wiki link.
			*/
			void attachTexture1D(const GLenum& target, const GLenum& attachment, const GLenum& texTarget, const GLuint& textureID, const GLint& level = 0);
			/**
			@copydoc FrameBuffer#attachTexture1D(const GLenum&, const GLenum&, const GLenum&, const GLuint&, const GLint&)
			*/
			void attachTexture2D(const GLenum& target, const GLenum& attachment, const GLenum& texTarget, const GLuint& textureID, const GLint& level = 0);
			/**
			@copydoc FrameBuffer#attachTexture1D(const GLenum&, const GLenum&, const GLenum&, const GLuint&, const GLint&)
			@param layer Which layer of the 3-dimensional image to use. It is 0 by default.
			*/
			void attachTexture3D(const GLenum& target, const GLenum& attachment, const GLenum& texTarget, const GLuint& textureID, const GLint& level = 0, const GLint& layer = 0);

			/**
			Attaches a single layer from a texture to this `FrameBuffer`
			@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
			@param attachment Which attachment port to use.
			@param texture ID for the `Texture` to attach. See Texture#getID() const
			@param level Mipmap level to attach. Is 0 by default.
			@param layer Which layer of the texture to use. It is 0 by default.
			@see https://www.opengl.org/wiki/GLAPI/glFramebufferTextureLayer
			@opengl
			*/
			void attachTextureLayer(const GLenum& target, const GLenum& attachment, const GLuint& texture, const GLint& level = 0, const GLint& layer = 0);

			/**
			Attaches a `RenderBuffer` to this `FrameBuffer` for rendering.
			@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
			@param attachment Which attachment port to use
			@param buffer The `RenderBuffer` to use.
			@see https://www.opengl.org/wiki/GLAPI/glFramebufferRenderbuffer
			*/
			void attachRenderbuffer(const GLenum& target, const GLenum& attachment, const RenderBuffer& buffer);

			/**
			Specifies what buffers to render to. Takes in an array of attachments. A `RenderBuffer` or `Texture` can be attached to act
			as a draw buffer.
			@param arrSize Size of the array of render buffers
			@param buffers Pointer to the first element of the array
			@see https://www.opengl.org/wiki/GLAPI/glDrawBuffers
			@see FrameBuffer#attachTexture(const GLenum&, const GLenum&, const GLenum&, const GLuint&)
			@see FrameBuffer#attachTexture1D(const GLenum&, const GLenum&, const GLenum&, const GLuint&, const GLint&)
			@see FrameBuffer#attachTexture2D(const GLenum&, const GLenum&, const GLenum&, const GLuint&, const GLint&)
			@see FrameBuffer#attachTexture2D(const GLenum&, const GLenum&, const GLenum&, const GLuint&, const GLint&, const GLint&)
			@see FrameBuffer#attachTextureLayer(const GLenum&, const GLenum&, const GLuint&, const GLint&)
			@see FrameBuffer#attachRenderbuffer(const GLenum&, const GLenum&, const RenderBuffer&)
			@opengl
			*/
			void setDrawBuffers(const Size& arrSize, const GLenum* buffers);

			bool isCreated() const;

			/**
			Queries OpenGL for the status of this `FrameBuffer.` Can be used to detect whether this `FrameBuffer` encountered an error
			during creation.
			@param target The framebuffer target. Must be `GL_DRAW_FRAMEBUFFER`, `GL_READ_FRAMEBUFFER` or `GL_FRAMEBUFFER`
			@return The `FrameBuffer` status. The full list of enums is described in the OpenGL specification.
			@see https://www.opengl.org/wiki/GLAPI/glCheckFramebufferStatus
			@opengl
			*/
			GLenum checkStatus(const GLenum& target);

			using Object::operator==;
			using Object::operator!=;
		private:
			void bindIndex(const Index& id) const;
		};//FrameBuffer

		/**
		@see https://www.opengl.org/wiki/Texture
		*/
		class Texture: public Object {
		public:
			void init();
			void destroy();

			/**
			@see https://www.opengl.org/wiki/GLAPI/glTexImage2D
			@opengl
			*/
			void setData(const void * data, Size width, Size height, GLenum type = GL_FLOAT, GLenum format = GL_RGB, GLenum internalFormat = GL_RGB, Index mipmapLevel = 0);

			/**
			@opengl
			*/
			void loadFile(const char* file);

			void setTarget(const GLenum target);
			GLenum getTarget();

			Color& getPaint();
			const Color& getPaint() const;
			void setPaint(const Color& c);

			float getOpacity();
			const float getOpacity() const;
			void setOpacity(const float f);

			bool isCreated() const;

			/**
			@see https://www.opengl.org/wiki/GLAPI/glTexParameter
			@opengl
			*/
			void setParameter(const GLenum& name, const GLint& value);

			bool operator==(const Texture& other) const;
			bool operator!=(const Texture& other) const;

		private:
			GLenum target = GL_TEXTURE_2D;

			Color paint = Color(1.0f, 1.0f, 1.0f, 1.0f);

			float opacity = 1.0f;

			void bindIndex(const Index& id) const;
		};//Texture

		/**
		@todo Create a VBO class
		*/
		class VertexArray: public Object {
		public:
			Size vertexNumber, indiceNumber;

			void init();
			void destroy();

			bool isCreated() const;

			/**
			@see https://www.opengl.org/wiki/GLAPI/glDrawElements
			@opengl
			*/
			void draw(const GLenum type = GL_TRIANGLES) const;

			void loadVertices(const Size&& verticeSize, const GLfloat vertices[], const Index&& location = 15, const Size&& attributeSize = 3);
			void loadIndices(const Size&& indiceNum, const GLuint indices[], const GLenum&& drawType = GL_DYNAMIC_DRAW);

			void storeDataInAttributeList(const Size&& dataSize, const GLvoid* data, const Index&& location = 0, const Size&& attributeSize = 3);
		
			bool operator==(const VertexArray& other) const;
			bool operator!=(const VertexArray& other) const;
		private:
			void bindIndex(const Index& id) const;
		};//VertexArray

		class Buffer: public Object {
		public:
			virtual ~Buffer() = default;

			Buffer(const GLenum bufferType);

			bool isCreated() const;

			void init();
			void destroy();

			/**
			@see https://www.opengl.org/wiki/GLAPI/glBufferStorage
			@opengl
			*/
			void setImmutableData(const GLsizeiptr dataSize, const GLvoid* data, GLbitfield flags);
			/**
			@see https://www.opengl.org/wiki/GLAPI/glBufferData
			@opengl
			*/
			void setData(const GLsizeiptr dataSize, const GLvoid* data, const GLenum drawType = GL_DYNAMIC_DRAW) const;
			/**
			@see https://www.opengl.org/wiki/GLAPI/glBufferSubData
			@opengl
			*/
			void setDataRange(const Index offset, const GLsizeiptr dataSize, const GLvoid* data) const;

			/**
			@see https://www.opengl.org/wiki/GLAPI/glCopyBufferSubData
			@opengl
			*/
			void copyData(Buffer other, GLsizeiptr size, Index readOffset = 0, Index writeOffset = 0);

			/**
			@see https://www.opengl.org/wiki/GLAPI/glMapBuffer
			@opengl
			*/
			GLvoid* map(const GLenum access = GL_READ_WRITE);

			/**
			@see https://www.opengl.org/wiki/GLAPI/glMapBufferRange
			@opengl
			*/
			GLvoid* mapRange(const Index offset, const Size length, const GLbitfield access);

			/**
			@see https://www.opengl.org/wiki/GLAPI/glMapBuffer
			@opengl
			*/
			GLboolean unmap();

			bool operator==(const Buffer& other) const;
			bool operator!=(const Buffer& other) const;
		private:
			GLenum bufferType;

			void bindIndex(const Index& id) const;
		};//Buffer

		class UniformBuffer: public Buffer {
		public:
			UniformBuffer();

			void setLocation(const Index location);
			Index getLocation();
			const Index getLocation() const;

			/**
			@see https://www.opengl.org/wiki/GLAPI/glBindBufferBase
			@see https://www.opengl.org/wiki/GLAPI/glBindBufferRange
			@opengl
			*/
			void bindForRender(const Index offset = 0, const GLsizeiptr size = -1) const;

			/**
			@see https://www.opengl.org/wiki/GLAPI/glUniformBlockBinding
			@opengl
			*/
			void bindToUniformBlock(const Index programID, const char* blockName) const;

			bool operator==(const UniformBuffer& other) const;
			bool operator!=(const UniformBuffer& other) const;
		private:
			Index location = 0;
		};//UniformBuffer

	}//gfx
}//mc

#endif