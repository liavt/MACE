.TH "mc::gfx::Button" 3 "Sat Apr 8 2017" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::gfx::Button \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Entity2D\&.h>\fP
.PP
Inherits \fBmc::gfx::Selectable\fP, and \fBmc::gfx::Entity2D\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "const \fBColorAttachment\fP & \fBgetTexture\fP () const "
.br
.ti -1c
.RI "\fBColorAttachment\fP & \fBgetTexture\fP ()"
.br
.ti -1c
.RI "void \fBsetTexture\fP (const \fBColorAttachment\fP &c)"
.br
.ti -1c
.RI "const \fBColorAttachment\fP & \fBgetHoverTexture\fP () const "
.br
.ti -1c
.RI "\fBColorAttachment\fP & \fBgetHoverTexture\fP ()"
.br
.ti -1c
.RI "void \fBsetHoverTexture\fP (const \fBColorAttachment\fP &c)"
.br
.ti -1c
.RI "const \fBColorAttachment\fP & \fBgetClickedTexture\fP () const "
.br
.ti -1c
.RI "\fBColorAttachment\fP & \fBgetClickedTexture\fP ()"
.br
.ti -1c
.RI "void \fBsetClickedTexture\fP (const \fBColorAttachment\fP &c)"
.br
.ti -1c
.RI "const \fBColorAttachment\fP & \fBgetDisabledTexture\fP () const "
.br
.ti -1c
.RI "\fBColorAttachment\fP & \fBgetDisabledTexture\fP ()"
.br
.ti -1c
.RI "void \fBsetDisabledTexture\fP (const \fBColorAttachment\fP &c)"
.br
.ti -1c
.RI "bool \fBisClicked\fP () const "
.br
.ti -1c
.RI "bool \fBisDisabled\fP () const "
.br
.ti -1c
.RI "bool \fBisHovered\fP () const "
.br
.ti -1c
.RI "void \fBclick\fP ()"
.br
.ti -1c
.RI "void \fBdisable\fP ()"
.br
.ti -1c
.RI "void \fBenable\fP ()"
.br
.ti -1c
.RI "void \fBtrigger\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBgetProtocol\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum \fBSelectableProperty\fP : Byte { \fBCLICKED\fP = 0, \fBDISABLED\fP = 1, \fBHOVERED\fP = 2 }"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBonInit\fP () override"
.br
.RI "\fIWhen \fC\fBEntity\&.init()\fP\fP is called, \fC\fBonInit()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonUpdate\fP () override"
.br
.RI "\fIWhen \fC\fBEntity\&.update()\fP\fP is called, \fC\fBonUpdate()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonRender\fP () override"
.br
.RI "\fIWhen \fC\fBEntity\&.render()\fP\fP is called, \fC\fBonRender()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonDestroy\fP () override"
.br
.RI "\fIWhen \fC\fBEntity\&.destroy()\fP\fP is called, \fC\fBonDestroy()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonHover\fP () override"
.br
.ti -1c
.RI "void \fBonClean\fP () override"
.br
.ti -1c
.RI "virtual void \fBonClick\fP ()"
.br
.ti -1c
.RI "virtual void \fBonEnable\fP ()"
.br
.ti -1c
.RI "virtual void \fBonDisable\fP ()"
.br
.ti -1c
.RI "virtual void \fBonTrigger\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBBitField\fP \fBselectableProperties\fP = 0"
.br
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "enum \fBEntityProperty\fP : Byte { \fBDEAD\fP = 0, \fBDISABLED\fP = 1, \fBINIT\fP = 2, \fBDIRTY\fP = 3, \fBMAINTAIN_X\fP = 4, \fBMAINTAIN_Y\fP = 5, \fBMAINTAIN_WIDTH\fP = 6, \fBMAINTAIN_HEIGHT\fP = 7, \fBDEFAULT_PROPERTIES\fP = 0b00000000 }"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBogl::UniformBuffer\fP & \fBgetBuffer\fP ()"
.br
.ti -1c
.RI "const \fBogl::UniformBuffer\fP & \fBgetBuffer\fP () const "
.br
.ti -1c
.RI "void \fBsetBuffer\fP (const \fBogl::UniformBuffer\fP &newBuffer)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBEntity2D\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBGraphicsEntity\fP &other) const  noexcept"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBEntity\fP &other) const  noexcept"
.br
.RI "\fICompares if 2 \fCEntities\fP have the same children, parent, and properties\&. \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBEntity2D\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBGraphicsEntity\fP &other) const  noexcept"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBEntity\fP &other) const  noexcept"
.br
.RI "\fICompares if 2 \fCEntities\fP don't have the same children, parent, and properties\&. \fP"
.ti -1c
.RI "void \fBclean\fP () final"
.br
.ti -1c
.RI "void \fBinit\fP () final"
.br
.RI "\fIShould be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.init()\fP\fP is called\&. \fP"
.ti -1c
.RI "void \fBdestroy\fP () final"
.br
.RI "\fIShould be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.destroy()\fP\fP is called\&. \fP"
.ti -1c
.RI "float \fBgetOpacity\fP ()"
.br
.ti -1c
.RI "const float \fBgetOpacity\fP () const "
.br
.ti -1c
.RI "void \fBsetOpacity\fP (const float f)"
.br
.ti -1c
.RI "const std::vector< \fBEntity\fP * > & \fBgetChildren\fP () const "
.br
.RI "\fIGets all of this \fC\fBEntity\fP's\fP children\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (const \fBEntity\fP &e)"
.br
.RI "\fIRemoves a child\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (const \fBEntity\fP *e)"
.br
.RI "\fIRemoves a child\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (\fBIndex\fP index)"
.br
.RI "\fIRemoves a child via location\&. \fP"
.ti -1c
.RI "bool \fBhasChild\fP (\fBEntity\fP &e) const "
.br
.RI "\fIChecks to see if this \fC\fBEntity\fP\fP contains an \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "void \fBclearChildren\fP ()"
.br
.RI "\fIRemoves EVERY \fC\fBEntity\fP\fP from this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "\fBEntity\fP & \fBoperator[]\fP (\fBIndex\fP i)"
.br
.RI "\fIAccess an \fC\fBEntity\fP\fP\&. \fP"
.ti -1c
.RI "const \fBEntity\fP & \fBoperator[]\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fBoperator[](Index i)\fP \fP"
.ti -1c
.RI "\fBEntity\fP & \fBgetChild\fP (\fBIndex\fP i)"
.br
.RI "\fIRetrieves a child at a certain index\&. \fP"
.ti -1c
.RI "const \fBEntity\fP & \fBgetChild\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fBgetChild(Index)\fP \fP"
.ti -1c
.RI "int \fBindexOf\fP (const \fBEntity\fP &e) const "
.br
.RI "\fIFinds the location of an \fC\fBEntity\fP\fP in this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const "
.br
.RI "\fIChecks whether this \fC\fBEntity\fP\fP has any children\&. \fP"
.ti -1c
.RI "std::vector< \fBEntity\fP * >::iterator \fBbegin\fP ()"
.br
.RI "\fIRetrieves the beginning of the children of this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "std::vector< \fBEntity\fP * >::iterator \fBend\fP ()"
.br
.RI "\fIRetrieves the end of the children of this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "\fBSize\fP \fBsize\fP () const "
.br
.RI "\fICalculates the amount of children this \fC\fBEntity\fP\fP has\&. \fP"
.ti -1c
.RI "\fBEntityProperties\fP & \fBgetProperties\fP ()"
.br
.RI "\fIRetrieves the \fC\fBEntity\fP's\fP properties as a \fCByteField\fP \fP"
.ti -1c
.RI "const \fBEntityProperties\fP & \fBgetProperties\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetProperties()\fP\fP \fP"
.ti -1c
.RI "void \fBsetProperties\fP (\fBEntityProperties\fP &b)"
.br
.RI "\fISet the properties for this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "bool \fBgetProperty\fP (const \fBByte\fP position) const "
.br
.RI "\fIRetrieve the value of a property\&. \fP"
.ti -1c
.RI "void \fBsetProperty\fP (const \fBByte\fP position, const bool value)"
.br
.RI "\fISet a property to be \fCtrue\fP or \fCfalse\fP\&. \fP"
.ti -1c
.RI "\fBTransformMatrix\fP & \fBgetTransformation\fP ()"
.br
.ti -1c
.RI "const \fBTransformMatrix\fP & \fBgetTransformation\fP () const "
.br
.ti -1c
.RI "void \fBsetTransformation\fP (\fBTransformMatrix\fP &trans)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBtranslate\fP (float x, float y, float z=0\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBrotate\fP (float x, float y, float z=0\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBscale\fP (float x, float y, float z=1\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP *const \fBgetParent\fP ()"
.br
.RI "\fIRetrieve this \fCEntitys\fP parent `Entity\&. \fP"
.ti -1c
.RI "const \fBEntity\fP *const \fBgetParent\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetParent()\fP\fP \fP"
.ti -1c
.RI "bool \fBhasParent\fP () const "
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBEntity\fP &e)"
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBEntity\fP *e)"
.br
.ti -1c
.RI "void \fBaddComponent\fP (\fBComponent\fP *action)"
.br
.ti -1c
.RI "void \fBaddComponent\fP (\fBComponent\fP &action)"
.br
.ti -1c
.RI "std::vector< \fBComponent\fP * > \fBgetComponents\fP ()"
.br
.ti -1c
.RI "const float & \fBgetWidth\fP () const "
.br
.ti -1c
.RI "float & \fBgetWidth\fP ()"
.br
.ti -1c
.RI "void \fBsetWidth\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetHeight\fP () const "
.br
.ti -1c
.RI "float & \fBgetHeight\fP ()"
.br
.ti -1c
.RI "void \fBsetHeight\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetDepth\fP () const "
.br
.ti -1c
.RI "float & \fBgetDepth\fP ()"
.br
.ti -1c
.RI "void \fBsetDepth\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetX\fP () const "
.br
.ti -1c
.RI "float & \fBgetX\fP ()"
.br
.ti -1c
.RI "void \fBsetX\fP (const float &newX)"
.br
.ti -1c
.RI "const float & \fBgetY\fP () const "
.br
.ti -1c
.RI "float & \fBgetY\fP ()"
.br
.ti -1c
.RI "void \fBsetY\fP (const float &newY)"
.br
.ti -1c
.RI "const float & \fBgetZ\fP () const "
.br
.ti -1c
.RI "float & \fBgetZ\fP ()"
.br
.ti -1c
.RI "void \fBsetZ\fP (const float &newY)"
.br
.ti -1c
.RI "const \fBEntity\fP * \fBgetRoot\fP () const "
.br
.RI "\fIRetrieves the top most parent (known as the 'root\&.') \fP"
.ti -1c
.RI "\fBEntity\fP * \fBgetRoot\fP ()"
.br
.RI "\fIRetrieves the top most parent (known as the 'root\&.') \fP"
.ti -1c
.RI "\fBMetrics\fP \fBgetMetrics\fP () const "
.br
.ti -1c
.RI "void \fBreset\fP ()"
.br
.ti -1c
.RI "void \fBmakeDirty\fP ()"
.br
.RI "\fIMakes this \fC\fBEntity\fP\fP dirty and root dirty\&. \fP"
.ti -1c
.RI "virtual void \fBupdate\fP ()"
.br
.RI "\fIShould be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.update()\fP\fP is called\&. \fP"
.ti -1c
.RI "virtual void \fBrender\fP ()"
.br
.RI "\fIShould be called by a \fC\fBEntity\fP\fP when the graphical \fCWindow\fP clears the frame\&. \fP"
.ti -1c
.RI "virtual void \fBhover\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBogl::UniformBuffer\fP \fBbuffer\fP = \fBogl::UniformBuffer\fP()"
.br
.ti -1c
.RI "std::vector< \fBEntity\fP * > \fBchildren\fP = std::vector<\fBEntity\fP*>()"
.br
.RI "\fI\fCstd::vector\fP of this \fC\fBEntity\fP\\'s\fP children\&. \fP"
.ti -1c
.RI "\fBTransformMatrix\fP \fBtransformation\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBRenderProtocol< Button >\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 441 of file Entity2D\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBmc::gfx::Selectable::SelectableProperty\fP : \fBByte\fP\fC [protected]\fP, \fC [inherited]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fICLICKED \fP\fP
.TP
\fB\fIDISABLED \fP\fP
.TP
\fB\fIHOVERED \fP\fP
.PP
Definition at line 832 of file Entity\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void mc::gfx::Selectable::click ()\fC [inherited]\fP"

.SS "void mc::gfx::Selectable::disable ()\fC [inherited]\fP"

.SS "void mc::gfx::Selectable::enable ()\fC [inherited]\fP"

.SS "const \fBColorAttachment\fP& mc::gfx::Button::getClickedTexture () const"

.SS "\fBColorAttachment\fP& mc::gfx::Button::getClickedTexture ()"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBColorAttachment\fP& mc::gfx::Button::getDisabledTexture () const"

.SS "\fBColorAttachment\fP& mc::gfx::Button::getDisabledTexture ()"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBColorAttachment\fP& mc::gfx::Button::getHoverTexture () const"

.SS "\fBColorAttachment\fP& mc::gfx::Button::getHoverTexture ()"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "static int mc::gfx::Button::getProtocol ()\fC [static]\fP"

.SS "const \fBColorAttachment\fP& mc::gfx::Button::getTexture () const"

.SS "\fBColorAttachment\fP& mc::gfx::Button::getTexture ()"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "bool mc::gfx::Selectable::isClicked () const\fC [inherited]\fP"

.SS "bool mc::gfx::Selectable::isDisabled () const\fC [inherited]\fP"

.SS "bool mc::gfx::Selectable::isHovered () const\fC [inherited]\fP"

.SS "void mc::gfx::Button::onClean ()\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Entity\fP\&.
.SS "virtual void mc::gfx::Selectable::onClick ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.SS "void mc::gfx::Button::onDestroy ()\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.destroy()\fP\fP is called, \fC\fBonDestroy()\fP\fP is called on all of it's children\&. 
.PP
\fBSee also:\fP
.RS 4
\fBMACE::destroy()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "virtual void mc::gfx::Selectable::onDisable ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.SS "virtual void mc::gfx::Selectable::onEnable ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.SS "void mc::gfx::Button::onHover ()\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Entity\fP\&.
.SS "void mc::gfx::Button::onInit ()\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.init()\fP\fP is called, \fC\fBonInit()\fP\fP is called on all of it's children\&. 
.PP
\fBSee also:\fP
.RS 4
\fBMACE::init()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "void mc::gfx::Button::onRender ()\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.render()\fP\fP is called, \fC\fBonRender()\fP\fP is called on all of it's children\&. 
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "virtual void mc::gfx::Selectable::onTrigger ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.SS "void mc::gfx::Button::onUpdate ()\fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.update()\fP\fP is called, \fC\fBonUpdate()\fP\fP is called on all of it's children\&. 
.PP
\fBSee also:\fP
.RS 4
\fBMACE::update()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "void mc::gfx::Button::setClickedTexture (const \fBColorAttachment\fP & c)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Button::setDisabledTexture (const \fBColorAttachment\fP & c)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Button::setHoverTexture (const \fBColorAttachment\fP & c)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Button::setTexture (const \fBColorAttachment\fP & c)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Selectable::trigger ()\fC [inherited]\fP"

.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBRenderProtocol\fP< \fBButton\fP >\fC [friend]\fP"

.PP
Definition at line 442 of file Entity2D\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBBitField\fP mc::gfx::Selectable::selectableProperties = 0\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 838 of file Entity\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
