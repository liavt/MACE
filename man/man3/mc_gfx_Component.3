.TH "mc::gfx::Component" 3 "Sun Apr 9 2017" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::gfx::Component \- Can be plugged into an \fC\fBEntity\fP\fP to allow for additional functionality by listening to events\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Entity\&.h>\fP
.PP
Inherited by \fBmc::gfx::AlignmentComponent\fP, \fBmc::gfx::CallbackComponent\fP, and \fBmc::gfx::FPSComponent\fP\&.
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~Component\fP ()=default"
.br
.ti -1c
.RI "virtual void \fBinit\fP (\fBEntity\fP *e)"
.br
.RI "\fICalled when this \fC\fBComponent\fP\fP is added to the \fC\fBEntity\fP\fP via \fBEntity::addComponent(Component&)\fP\&. \fP"
.ti -1c
.RI "virtual bool \fBupdate\fP (\fBEntity\fP *e)"
.br
.RI "\fICalled when \fBEntity::update()\fP is called\&. \fP"
.ti -1c
.RI "virtual void \fBdestroy\fP (\fBEntity\fP *e)"
.br
.RI "\fICalled when \fBEntity::destroy()\fP is called or the \fC\fBComponent\fP\fP is removed via \fBComponent::update(Entity*)\fP, whichever comes first\&. \fP"
.ti -1c
.RI "virtual void \fBrender\fP (\fBEntity\fP *e)"
.br
.ti -1c
.RI "virtual void \fBclean\fP (\fBEntity\fP *e)"
.br
.RI "\fICalled when \fBEntity::clean()\fP is called and it was dirty\&. \fP"
.ti -1c
.RI "virtual void \fBhover\fP (\fBEntity\fP *e)"
.br
.ti -1c
.RI "\fBEntity\fP * \fBgetParent\fP ()"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBComponent\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBComponent\fP &other) const "
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBEntity\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Can be plugged into an \fC\fBEntity\fP\fP to allow for additional functionality by listening to events\&. 

Instead of extending an existing \fC\fBEntity\fP\fP subclass, you should prefer using a \fC\fBComponent\fP\fP to not interfere with custom \fBEntity::onRender()\fP and similar functions\&. 
.PP
Similarly to all objects in \fBMACE\fP, \fBComponent::init(Entity*)\fP is always called and \fBComponent::destroy(Entity*)\fP is also always called\&. 
.PP
Contains virtual functions for every event in an \fC\fBEntity\fP\fP which each have 1 parameter - the \fC\fBEntity\fP\fP being acted on\&. 
.PP
You are required to implement \fBComponent::init(Entity*)\fP, \fBComponent::update(Entity*)\fP, and \fBComponent::destroy(Entity*)\fP\&. There are additional functions which are optional to implement\&. 
.PP
There is no function to remove a \fC\fBComponent\fP\fP from an \fC\fBEntity\fP\fP\&. Instead, the \fC\fBComponent\fP\fP decides when to be removed from \fBComponent::update(Entity*)\fP\&. This makes sure that the \fC\fBComponent\fP\fP completes whatever task it was trying to do\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::addComponent(Component&)\fP 
.RE
.PP
\fBTodo\fP
.RS 4
unit testing for \fBclean()\fP \fBrender()\fP and \fBhover()\fP 
.RE
.PP

.PP
Definition at line 66 of file Entity\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "virtual mc::gfx::Component::~Component ()\fC [protected]\fP, \fC [virtual]\fP, \fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "virtual void mc::gfx::Component::clean (\fBEntity\fP * e)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when \fBEntity::clean()\fP is called and it was dirty\&. This is not required for inheritance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::FPSComponent\fP, \fBmc::gfx::CallbackComponent\fP, and \fBmc::gfx::AlignmentComponent\fP\&.
.SS "virtual void mc::gfx::Component::destroy (\fBEntity\fP * e)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when \fBEntity::destroy()\fP is called or the \fC\fBComponent\fP\fP is removed via \fBComponent::update(Entity*)\fP, whichever comes first\&. Once \fBComponent::destroy(Entity*)\fP is called, it is immediately removed from the \fC\fBEntity\fP\fP\&. Required function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::FPSComponent\fP, and \fBmc::gfx::CallbackComponent\fP\&.
.SS "\fBEntity\fP* mc::gfx::Component::getParent ()\fC [protected]\fP"

.SS "virtual void mc::gfx::Component::hover (\fBEntity\fP * e)\fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::FPSComponent\fP, and \fBmc::gfx::CallbackComponent\fP\&.
.SS "virtual void mc::gfx::Component::init (\fBEntity\fP * e)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when this \fC\fBComponent\fP\fP is added to the \fC\fBEntity\fP\fP via \fBEntity::addComponent(Component&)\fP\&. Required function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This is not called at \fBEntity::init()\fP, instead it is called when the component is added to the \fC\fBEntity\fP\fP\&. Keep that in mind\&. 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::FPSComponent\fP, and \fBmc::gfx::CallbackComponent\fP\&.
.SS "bool mc::gfx::Component::operator!= (const \fBComponent\fP & other) const\fC [protected]\fP"

.SS "bool mc::gfx::Component::operator== (const \fBComponent\fP & other) const\fC [protected]\fP"

.SS "virtual void mc::gfx::Component::render (\fBEntity\fP * e)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented in \fBmc::gfx::FPSComponent\fP, and \fBmc::gfx::CallbackComponent\fP\&.
.SS "virtual bool mc::gfx::Component::update (\fBEntity\fP * e)\fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when \fBEntity::update()\fP is called\&. Required function\&. 
.PP
There is no function to remove a \fC\fBComponent\fP\fP so this is the only way for a \fC\fBComponent\fP\fP to be removed from an \fC\fBEntity\fP\fP 
.PP
\fBComponent::destroy(Entity*)\fP will be called afterwards\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether this \fC\fBComponent\fP\fP should be deleted or not\&. 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::FPSComponent\fP, and \fBmc::gfx::CallbackComponent\fP\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBEntity\fP\fC [friend]\fP"

.PP
Definition at line 67 of file Entity\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
