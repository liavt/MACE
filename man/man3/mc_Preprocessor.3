.TH "mc::Preprocessor" 3 "Fri Nov 25 2016" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::Preprocessor \- Customizable string preprocessor which follows ANSI-C preprocessor standard\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Preprocessor\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPreprocessor\fP (const std::string &input, const std::string &filename='Unknown file')"
.br
.RI "\fICreates a \fC\fBPreprocessor\fP\fP \fP"
.ti -1c
.RI "\fBPreprocessor\fP (const std::string &input, const \fBPreprocessor\fP &clone)"
.br
.RI "\fIClones another \fC\fBPreprocessor\fP\fP and gives it a new input\&. \fP"
.ti -1c
.RI "std::vector< std::string > \fBpreprocessTokens\fP ()"
.br
.RI "\fIProcesseses the \fCinput\fP specified in the constructor according to the ANSI C standard\&. \fP"
.ti -1c
.RI "std::string \fBpreprocess\fP ()"
.br
.RI "\fIProcesseses the \fCinput\fP specified in the constructor according to the ANSI C standard\&. \fP"
.ti -1c
.RI "void \fBaddInclude\fP (\fBInclude\fP &incl)"
.br
.RI "\fIAdds an \fC\fBInclude\fP\fP to this preprocessor\&. \fP"
.ti -1c
.RI "std::vector< \fBInclude\fP * > \fBgetIncludes\fP ()"
.br
.RI "\fIRetrieves all pointers to an \fC\fBInclude\fP\fP added via \fC\fBaddInclude()\fP\fP or \fC\fBsetIncludes()\fP\fP \fP"
.ti -1c
.RI "const std::vector< \fBInclude\fP * > \fBgetIncludes\fP () const "
.br
.RI "\fIRetrieves all pointers to an \fC\fBInclude\fP\fP added via \fC\fBaddInclude()\fP\fP or \fC\fBsetIncludes()\fP\fP \fP"
.ti -1c
.RI "void \fBsetIncludes\fP (const std::vector< \fBInclude\fP * > includes)"
.br
.RI "\fISets all of the \fCIncludes\fP in this \fC\fBPreprocessor\fP\fP\&. \fP"
.ti -1c
.RI "const std::string \fBgetInput\fP () const "
.br
.RI "\fIRetrieves what this \fC\fBPreprocessor\fP\fP is processing\&. \fP"
.ti -1c
.RI "std::string \fBgetFilename\fP ()"
.br
.RI "\fIGets the filename of the file this is processing\&. \fP"
.ti -1c
.RI "const std::string \fBgetFilename\fP () const "
.br
.RI "\fIGets the filename of the file this is processing\&. \fP"
.ti -1c
.RI "void \fBsetFilename\fP (const std::string &filename)"
.br
.RI "\fIChanges the filename\&. \fP"
.ti -1c
.RI "unsigned int \fBgetLine\fP ()"
.br
.RI "\fIGets the current line number\&. \fP"
.ti -1c
.RI "const unsigned int \fBgetLine\fP () const "
.br
.RI "\fIGets the current line number\&. \fP"
.ti -1c
.RI "void \fBsetLine\fP (const unsigned int line)"
.br
.RI "\fISets the line number\&. \fP"
.ti -1c
.RI "void \fBdefineMacro\fP (const \fBMacro\fP &macro)"
.br
.RI "\fIDefines a \fC\fBMacro\fP\fP \fP"
.ti -1c
.RI "bool \fBisMacroDefined\fP (const std::string &name) const "
.br
.RI "\fIChecks if a \fC\fBMacro\fP\fP with a certain name is defined\&. \fP"
.ti -1c
.RI "void \fBundefineMacro\fP (const std::string &name)"
.br
.RI "\fIRemoves a \fC\fBMacro\fP\fP with the specified name\&. \fP"
.ti -1c
.RI "unsigned int \fBmacroNumber\fP () const "
.br
.RI "\fICalculates the amount of \fCMacros\fP in this \fC\fBPreprocessor\fP\fP \fP"
.ti -1c
.RI "void \fBdefineStandardMacros\fP ()"
.br
.RI "\fIDefines macros required by ANSI C and various compiler-specific macros\&. \fP"
.ti -1c
.RI "void \fBdefineOSMacros\fP ()"
.br
.RI "\fIDefines macros that determine what OS you are on\&. \fP"
.ti -1c
.RI "const \fBMacro\fP & \fBgetMacro\fP (const std::string &name) const "
.br
.RI "\fIFinds a \fC\fBMacro\fP\fP with the given name\&. \fP"
.ti -1c
.RI "std::string \fBgetLocation\fP () const "
.br
.RI "\fIGenerates a string with the current line number and file name\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Customizable string preprocessor which follows ANSI-C preprocessor standard\&. 

It can define all standard and operating system macros with special functions\&. Additionally, the following macros are always defined: \fBMacro\fP name \fBMacro\fP definition  \fC__MACE__\fP Always defined \fC__INCLUDE_LEVEL__\fP Incremented by 1 when a file is included, and decremented when the included file ends\&. Identical to the GCC macro of the same name \fC__IF_SCOPE__\fP The depth of the current preprocessor conditional\&. Shouldn't be used\&. \fC__CURRENT_IF_SCOPE__\fP The level at which a conditional directive returned false\&. Shouldn't be used\&. Even if they are not defined, you can never defined or undefine a standard macro as denoted by the ANSI-C standard\&. You also can't define or undefine keywords 
.PP
Every directive in the ANSI-C standard is supported except for \fC#if\fP, \fC#elif\fP, and \fC#pragma\fP\&. \fC#warning\fP outputs a message to console\&. Additionally, \fC#version\fP is silenty ignored instead of being an error for GLSL support\&. 
.PP
Each \fC\fBPreprocessor\fP\fP object stores a single string called the \fCinput\fP\&. The only way to change the \fCinput\fP is by cloning it via a special constructor\&. 
.PP
\fC\fBPreprocessor\fP\fP can also 'fake' include files through the \fC\fBIncludeString\fP\fP class, allowing it to preprocess the same at every runtime invocation\&. 
.PP
The \fCssl\fP uses the \fC\fBPreprocessor\fP\fP class to handle shader files\&.
.PP
\fBSee also:\fP
.RS 4
\fBMacro\fP 
.PP
\fBInclude\fP 
.PP
\fBgfx::ssl\fP 
.RE
.PP
\fBTodo\fP
.RS 4
Digraphs (see 6\&.4\&.6 of standard) 
.PP
Variable arguments 
.PP
\fBMacro\fP concat 
.PP
\fC#if and\fP#elif` 
.PP
\fC#pragma\fP (if STDC follows, do no macro replacement) 
.RE
.PP

.PP
Definition at line 161 of file Preprocessor\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "mc::Preprocessor::Preprocessor (const std::string & input, const std::string & filename = \fC'Unknown file'\fP)"

.PP
Creates a \fC\fBPreprocessor\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP What to process\&. 
.br
\fIfilename\fP Name of the file that it is processing\&. This is used when an error happens\&. If not provided, 'Unknown file' is used instead\&. 
.RE
.PP

.SS "mc::Preprocessor::Preprocessor (const std::string & input, const \fBPreprocessor\fP & clone)\fC [explicit]\fP"

.PP
Clones another \fC\fBPreprocessor\fP\fP and gives it a new input\&. Macros and includes are all cloned\&. 
.PP
\fBParameters:\fP
.RS 4
\fIinput\fP New string that should be processed\&. 
.br
\fIclone\fP Another \fC\fBPreprocessor\fP\fP whose features should be cloned\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void mc::Preprocessor::addInclude (\fBInclude\fP & incl)"

.PP
Adds an \fC\fBInclude\fP\fP to this preprocessor\&. Any \fC\fBInclude\fP\fP's in this \fC\fBPreprocessor\fP\fP will be used when #include is encountered\&. 
.PP
Because this function takes in a reference, the \fC\fBInclude\fP\fP provided must remain owned by the program when \fC\fBpreprocess()\fP\fP or \fC\fBpreprocessTokens()\fP\fP is called\&. 
.PP
\fBParameters:\fP
.RS 4
\fIincl\fP Reference to an \fC\fBInclude\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBpreprocess()\fP 
.PP
\fBIncludeDirectory\fP 
.PP
\fBIncludeString\fP 
.RE
.PP

.SS "void mc::Preprocessor::defineMacro (const \fBMacro\fP & macro)"

.PP
Defines a \fC\fBMacro\fP\fP Called when #define is found in the \fCinput\fP 
.PP
\fBParameters:\fP
.RS 4
\fImacro\fP What to define\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBMacro\fP 
.PP
\fBundefineMacro(const std::string&)\fP 
.RE
.PP

.SS "void mc::Preprocessor::defineOSMacros ()"

.PP
Defines macros that determine what OS you are on\&. The values of these macros are determined at compile time based on your compiler 
.PP
\fBSee also:\fP
.RS 4
\fBdefineStandardMacros()\fP 
.RE
.PP

.SS "void mc::Preprocessor::defineStandardMacros ()"

.PP
Defines macros required by ANSI C and various compiler-specific macros\&. However, it will not define compiler-defining macros such as \fC__GCC__\fP\&. 
.PP
Compiler-specific macros are from the following compilers:
.IP "\(bu" 2
GCC
.IP "\(bu" 2
VC++
.IP "\(bu" 2
Clang
.IP "\(bu" 2
Intel
.IP "\(bu" 2
Borland
.IP "\(bu" 2
Oracle 
.PP
.PP
These function will only define macros that have values at the time that MACE is compiled\&. For example, if you compiler does not define \fC__STDC__\fP, this function will not define \fC__STDC__\fP\&. Additionally, only standard macros documented in the compiler's manual will be defined here\&. Custom macros that you define in the MACE compilation will not be defined by this function\&. For that, use the \fCdefineMacro(Macro)\fP function\&. 
.PP
Table of standard, non compiler specific macros: \fBMacro\fP name \fBMacro\fP definition  \fC__FILE__\fP The current filename as specified by the constructor, #include, or,\fC#line\fP directive\&. If \fC#line\fP is called, this macro is defined even if \fC\fBdefineStandardMacros()\fP\fP was not called\&. \fC__LINE__\fP The current line number in the file\&. Can be changed via \fC#line\fP\&. If \fC#line\fP is called, this macro is defined even if \fC\fBdefineStandardMacros()\fP\fP was not called\&. \fC__DATE__\fP Equal to the date at which the \fCinput\fP was processed with the format MNN DD YYYY\&. Only updates when \fC\fBdefineStandardMacros()\fP\fP is called\&. \fC__TIME__\fP Equal to the time at which the \fCinput\fP was processed with the format HH:MM:SS\&. Only updates when \fC\fBdefineStandardMacros()\fP\fP is called\&. \fC__BASE_FILE__\fP The filename from which the processing starts\&. #include does not affect this macro, but #line does\&. \fC__STDC__\fP Whether the preprocessor follows standard\&. The value of this macro is dependent on the value of \fBSTDC\fP when MACE was compiled\&. \fC__STDC_HOSTED__\fP Whether this supports a hosted implementation\&. The value of this macro is equal to it's value when MACE was compiled\&. The standard requires this, so it is 1 most of the time\&. \fC__cpluplus\fP What version of C++ is being used\&. This is equal to the version used to compile MACE\&. 
.PP
\fBSee also:\fP
.RS 4
\fBdefineOSMacros()\fP 
.RE
.PP

.SS "std::string mc::Preprocessor::getFilename ()"

.PP
Gets the filename of the file this is processing\&. The filename is determined by the constructor, \fC#line\fP, or #include\&. 
.PP
The \fC__FILE__\fP macro is equal to whatever this function returns\&. 
.PP
\fBReturns:\fP
.RS 4
The name of the file being processed\&. 
.RE
.PP

.SS "const std::string mc::Preprocessor::getFilename () const"

.PP
Gets the filename of the file this is processing\&. The filename is determined by the constructor, \fC#line\fP, or #include\&. 
.PP
The \fC__FILE__\fP macro is equal to whatever this function returns\&. 
.PP
\fBReturns:\fP
.RS 4
The name of the file being processed\&. 
.RE
.PP

.SS "std::vector< \fBInclude\fP* > mc::Preprocessor::getIncludes ()"

.PP
Retrieves all pointers to an \fC\fBInclude\fP\fP added via \fC\fBaddInclude()\fP\fP or \fC\fBsetIncludes()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCstd::vector\fP containing all \fCIncludes\fP in this \fC\fBPreprocessor\fP\fP 
.RE
.PP

.SS "const std::vector< \fBInclude\fP* > mc::Preprocessor::getIncludes () const"

.PP
Retrieves all pointers to an \fC\fBInclude\fP\fP added via \fC\fBaddInclude()\fP\fP or \fC\fBsetIncludes()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCstd::vector\fP containing all \fCIncludes\fP in this \fC\fBPreprocessor\fP\fP 
.RE
.PP

.SS "const std::string mc::Preprocessor::getInput () const"

.PP
Retrieves what this \fC\fBPreprocessor\fP\fP is processing\&. Cannot be changed\&. Set by the constructor\&. 
.PP
\fBReturns:\fP
.RS 4
A \fCconst std::string\fP with the input\&. This will never change\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
Preprocessor(std::string, std::string) 
.RE
.PP

.SS "unsigned int mc::Preprocessor::getLine ()"

.PP
Gets the current line number\&. The \fC__LINE__\fP macro's value is always equal to this function and \fC#line\fP can change the line number\&. 
.PP
If the processing is done, this is equal to the amount of lines the input had\&. 
.PP
\fBReturns:\fP
.RS 4
The current line that is being processed\&. 
.RE
.PP

.SS "const unsigned int mc::Preprocessor::getLine () const"

.PP
Gets the current line number\&. The \fC__LINE__\fP macro's value is always equal to this function and \fC#line\fP can change the line number\&. 
.PP
If the processing is done, this is equal to the amount of lines the input had\&. 
.PP
\fBReturns:\fP
.RS 4
The current line that is being processed\&. 
.RE
.PP

.SS "std::string mc::Preprocessor::getLocation () const"

.PP
Generates a string with the current line number and file name\&. For example, a \fC\fBPreprocessor\fP\fP which is at line 30 in file foo will return 'Line 30 in foo' from \fBgetLocation()\fP 
.PP
\fBReturns:\fP
.RS 4
The current location in the file 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetLine()\fP 
.PP
\fBgetFilename()\fP 
.RE
.PP

.SS "const \fBMacro\fP& mc::Preprocessor::getMacro (const std::string & name) const"

.PP
Finds a \fC\fBMacro\fP\fP with the given name\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP What to look for 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBMacro\fP\fP with the specified name 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIPreprocessorException\fP If the \fC\fBMacro\fP\fP with the name is not found\&. 
.RE
.PP

.SS "bool mc::Preprocessor::isMacroDefined (const std::string & name) const"

.PP
Checks if a \fC\fBMacro\fP\fP with a certain name is defined\&. Called when \fC#if\fPdef is encountered in the \fCinput\fP 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Name of the \fC\fBMacro\fP\fP to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether it is defined\&. 
.RE
.PP

.SS "unsigned int mc::Preprocessor::macroNumber () const"

.PP
Calculates the amount of \fCMacros\fP in this \fC\fBPreprocessor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
Size of the internal \fC\fBMacro\fP\fP array\&. 
.RE
.PP

.SS "std::string mc::Preprocessor::preprocess ()"

.PP
Processeses the \fCinput\fP specified in the constructor according to the ANSI C standard\&. Macros are expanded, comments are stripped, and directives are executed\&. 
.PP
This is the same as using \fC\fBpreprocessTokens()\fP\fP with every element combined\&. 
.PP
\fBReturns:\fP
.RS 4
The processed input\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBpreprocessTokens()\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIPreprocessorException\fP If \fCinput\fP is not valid ANSI C code\&. 
.RE
.PP

.SS "std::vector< std::string > mc::Preprocessor::preprocessTokens ()"

.PP
Processeses the \fCinput\fP specified in the constructor according to the ANSI C standard\&. Macros are expanded, comments are stripped, and directives are executed\&. 
.PP
Processing is done in O(N) time, where N is the amount of characters in the input\&. The entire process is done in 1 loop\&. This is accomplished via a complex finite state machine\&. 
.PP
\fBReturns:\fP
.RS 4
A \fCstd::vector\fP with the processed output\&. Each element is a token as specified by the standard\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBpreprocess()\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIPreprocessorException\fP If \fCinput\fP is not valid ANSI C code\&. 
.RE
.PP

.SS "void mc::Preprocessor::setFilename (const std::string & filename)"

.PP
Changes the filename\&. When \fC#line\fP is called with 2 arguments in the \fCinput\fP, calls this function 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP What to change the internal filename to\&. \fC__FILE__\fP will be updated to reflect the change\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBPreprocessor::getLine()\fP 
.RE
.PP

.SS "void mc::Preprocessor::setIncludes (const std::vector< \fBInclude\fP * > includes)"

.PP
Sets all of the \fCIncludes\fP in this \fC\fBPreprocessor\fP\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIincludes\fP The new \fCIncludes\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBaddInclude(Include&)\fP 
.RE
.PP

.SS "void mc::Preprocessor::setLine (const unsigned int line)"

.PP
Sets the line number\&. This does not affect processing\&. This function is called when the \fC#line\fP directive is encountered in the \fCinput\fP 
.PP
\fBParameters:\fP
.RS 4
\fIline\fP The new line number 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetLine()\fP 
.RE
.PP

.SS "void mc::Preprocessor::undefineMacro (const std::string & name)"

.PP
Removes a \fC\fBMacro\fP\fP with the specified name\&. Called when #undef is encountered in the \fCinput\fP 
.PP
Because the standard requires #undef to silently do nothing if the macro does not exist, this function does the same\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Name of the \fC\fBMacro\fP\fP to undefine 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
