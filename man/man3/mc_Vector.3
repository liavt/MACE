.TH "mc::Vector< T, N >" 3 "Sat Apr 8 2017" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::Vector< T, N > \- 1-dimensional vector class that supports mathmatical operations\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Vector\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVector\fP ()"
.br
.RI "\fIDefault constructor\&. \fP"
.ti -1c
.RI "\fBVector\fP (const T arr[N])"
.br
.RI "\fIConsructs a \fC\fBVector\fP\fP from the contents of an array\&. \fP"
.ti -1c
.RI "\fBVector\fP (const std::array< T, N > &contents)"
.br
.RI "\fIConsructs a \fC\fBVector\fP\fP from the contents of an \fCstd::array\fP\&. \fP"
.ti -1c
.RI "\fBVector\fP (const std::initializer_list< T > args)"
.br
.RI "\fICreates a \fC\fBVector\fP\fP from an `std::initializer_list\&. \fP"
.ti -1c
.RI "\fBVector\fP (const \fBVector\fP< T, N\-1 > &v, const T &last)"
.br
.RI "\fIO(N) time\&. \fP"
.ti -1c
.RI "\fBVector\fP (const \fBVector\fP &obj)"
.br
.RI "\fICopies the contents of a \fC\fBVector\fP\fP into a new \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "std::array< T, N > & \fBgetContents\fP ()"
.br
.RI "\fIRetrieves the contents of this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "const std::array< T, N > & \fBgetContents\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetContents()\fP\fP \fP"
.ti -1c
.RI "void \fBsetContents\fP (const std::array< T, N > contents)"
.br
.RI "\fICopies the contents of an \fCstd::array\fP into this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "void \fBsetContents\fP (const T arr[N])"
.br
.RI "\fICopies the contents of an array into this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "constexpr \fBSize\fP \fBsize\fP () const  noexcept"
.br
.RI "\fIRetrieves how many elements this \fC\fBVector\fP\fP holds\&. \fP"
.ti -1c
.RI "T * \fBbegin\fP ()"
.br
.ti -1c
.RI "const T * \fBbegin\fP () const "
.br
.ti -1c
.RI "T * \fBend\fP ()"
.br
.ti -1c
.RI "const T * \fBend\fP () const "
.br
.ti -1c
.RI "T & \fBget\fP (\fBIndex\fP i)"
.br
.RI "\fIGet the value at a position\&. \fP"
.ti -1c
.RI "const T & \fBget\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fC\fBget(Index)\fP,\fP in case a \fC\fBVector\fP\fP is declared \fCconst\fP \fP"
.ti -1c
.RI "void \fBset\fP (\fBIndex\fP position, T value)"
.br
.RI "\fISet data at a certain position to equal a new value\&. \fP"
.ti -1c
.RI "const T * \fBflatten\fP (T arr[N]) const "
.br
.RI "\fICreates an array with the data of this \fC\fBVector\fP\fP, in O(N) time\&. \fP"
.ti -1c
.RI "\fBVector\fP< T, 1 > \fBx\fP () const "
.br
.ti -1c
.RI "\fBVector\fP< T, 1 > \fBy\fP () const "
.br
.ti -1c
.RI "\fBVector\fP< T, 1 > \fBz\fP () const "
.br
.ti -1c
.RI "\fBVector\fP< T, 1 > \fBw\fP () const "
.br
.ti -1c
.RI "\fBVector\fP< T, 2 > \fBxy\fP () const "
.br
.ti -1c
.RI "\fBVector\fP< T, 3 > \fBxyz\fP () const "
.br
.ti -1c
.RI "\fBVector\fP< T, 4 > \fBxyzw\fP () const "
.br
.ti -1c
.RI "T & \fBoperator[]\fP (\fBIndex\fP i)"
.br
.RI "\fIRetrieves the content at a certain \fCIndex\fP, zero indexed\&. \fP"
.ti -1c
.RI "const T & \fBoperator[]\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fC\fBoperator[](Index)\fP\fP used if a \fC\fBVector\fP\fP is declared \fCconst\fP\&. \fP"
.ti -1c
.RI "virtual T & \fBoperator()\fP (\fBIndex\fP i)"
.br
.RI "\fIRetrieves content at a certain \fCIndex\fP, not zero indexed\&. \fP"
.ti -1c
.RI "const T & \fBoperator()\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fC\fBoperator()(Index)\fP\fP\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator+\fP (const \fBVector\fP< T, N > &right) const "
.br
.RI "\fIAdds 2 \fCVectors\fP together\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator\-\fP (const \fBVector\fP< T, N > &right) const "
.br
.RI "\fISubtracts 2 \fCVectors\fP together\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator*\fP (const \fBVector\fP< T, 3 > &right) const "
.br
.RI "\fIMultiplies 2 \fCVectors\fP together\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator/\fP (const \fBVector\fP< T, 3 > &right) const "
.br
.RI "\fIDivides 2 \fCVectors\fP together\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator+\fP (const T scalar) const "
.br
.RI "\fITranslates a \fC\fBVector\fP\fP with a scalar\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator\-\fP (const T scalar) const "
.br
.RI "\fITranslates a \fC\fBVector\fP\fP with a scalar\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator*\fP (const T scalar) const "
.br
.RI "\fIMultiplies a \fC\fBVector\fP\fP by a scalar\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator/\fP (const T scalar) const "
.br
.RI "\fIDivides a \fC\fBVector\fP\fP by a scalar\&. \fP"
.ti -1c
.RI "void \fBoperator+=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fIAdds a \fC\fBVector\fP\fP to this one\&. \fP"
.ti -1c
.RI "void \fBoperator\-=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fISubtracts a \fC\fBVector\fP\fP from this one\&. \fP"
.ti -1c
.RI "void \fBoperator*=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fIMultiplies a \fC\fBVector\fP\fP by this one\&. \fP"
.ti -1c
.RI "void \fBoperator/=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fIDivides a \fC\fBVector\fP\fP by this one\&. \fP"
.ti -1c
.RI "void \fBoperator+=\fP (const T &scalar)"
.br
.RI "\fITranslates this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "void \fBoperator\-=\fP (const T &scalar)"
.br
.RI "\fITranslates this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "void \fBoperator*=\fP (const T &scalar)"
.br
.RI "\fIScales this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "void \fBoperator/=\fP (const T &scalar)"
.br
.RI "\fIDivides this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares whether 2 \fCVectors\fP have the same values\&. \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares whether 2 \fCVectors\fP don't have the same values\&. \fP"
.ti -1c
.RI "bool \fBoperator>\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC>\fP operator on 2 \fCVectors\fP elements\&. \fP"
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC>=\fP operator on 2 \fCVectors\fP elements\&. \fP"
.ti -1c
.RI "bool \fBoperator<\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC<\fP operator on 2 \fCVectors\fP elements\&. \fP"
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC<=\fP operator on 2 \fCVectors\fP elements\&. \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "T \fBcontent\fP [N]"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &output, const \fBVector\fP< T, N > &v)"
.br
.RI "\fIOperator used to output to \fCstd::cout\fP\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T, Size N>
.br
struct mc::Vector< T, N >"
1-dimensional vector class that supports mathmatical operations\&. 

\fCVectors\fP can be added, subtracted, and multiplied\&. by other \fCVectors\fP of equal width\&. Additionally, they can also be operated by a \fC\fBMatrix\fP\fP of equal width\&. \fCVectors\fP CANNOT be divided\&. 
.PP
\fC\fBVector\fP\fP math is done by adding the adjacent values of both vectors together\&. For example, we want to add these 2 \fCVectors\fP together: 
.PP
.nf
left = [55,42,-12,23]

right = [3,7,5,9]

result = left + right

.fi
.PP
 The result would be every value across from eachother added together, as so: 
.PP
.nf
result = [left[1]+right[1],left[2]+right[2],left[3]+right[3],left[4]+right[4]]

.fi
.PP
 or 
.PP
.nf
result = [58,49,-7,32]

.fi
.PP
 Multiplication, and subtraction are the same concept\&. To do math with \fBMACE\fP, all you need to do is to use the mathmatical operators\&. 
.PP
Examples: 
.PP
.nf
Vector<int,3> vector = Vector<int,3>();//Create a Vector of 3 ints

int array[] = {1,2,3};
vector = array;//Generate Vector from array

vector\&.get(i);//Get int from position i
vector[i];//get int from position i

vector\&.set(i,v);//Set int at position i to equal v
vector[i]=v;//set int at position i to equal v

vector\&.size() //Get how many elements the Vector has

//Iterate through a Vector:
for(Index i =0;i<vector\&.size();i++){
    int value = vector[i];
}

.fi
.PP
 
.PP
There are various type aliases in place to prevent using the template parameters\&. They all use the following syntax: \fC\fBVector\fP[size][prefix]\fP 
.PP
Prefixes exist for every primitive type and are the first letter of the primitive name\&. For example, the prefix for a \fCfloat\fP would be \fCf\fP and the prefix for an \fCint\fP would be \fCi\fP\&. Primitives with modifiers simply add the letter\&. The prefixed for an \fCunsigned char\fP would be \fCuc\fP and the prefix for a \fClong long int\fP would be \fClli\fP 
.PP
Sizes exist for vertices up to 5 objects 
.PP
For example, to create a \fC\fBVector\fP\fP that is made up of 4 floats, you would use \fCVector4f\fP\&. For a \fC\fBVector\fP\fP of 2 unsigned ints, you would use \fCVector2ui\fP 
.PP
\fBSee also:\fP
.RS 4
\fBMatrix\fP 
.RE
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIT\fP what the \fC\fBVector\fP\fP is made of and calculates with\&. Can be any type/ 
.br
\fIN\fP amount of elements in the \fC\fBVector\fP\fP which must be greater than 0\&. 
.RE
.PP

.PP
Definition at line 89 of file Vector\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP ()\fC [inline]\fP"

.PP
Default constructor\&. Constructs an empty \fC\fBVector\fP\fP 
.PP
Definition at line 94 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const T arr[N])\fC [inline]\fP"

.PP
Consructs a \fC\fBVector\fP\fP from the contents of an array\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarr\fP An equally-sized array whose contents will be filled into a \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 102 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const std::array< T, N > & contents)\fC [inline]\fP"

.PP
Consructs a \fC\fBVector\fP\fP from the contents of an \fCstd::array\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcontents\fP An equally-sized \fCstd::array\fP whose contents will be filled into a \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 111 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const std::initializer_list< T > args)\fC [inline]\fP"

.PP
Creates a \fC\fBVector\fP\fP from an `std::initializer_list\&. ` Allows for an aggregate-style creation\&. 
.PP
Example: 
.PP
.nf
Vector3i mat = {1, 2, 3};

.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIargs\fP What to create this \fC\fBVector\fP\fP with 
.RE
.PP
\fBTodo\fP
.RS 4
Make this constexpr 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBoundsException\fP If the amount of arguments in the initializer is not equal to the amount of objects this \fC\fBVector\fP\fP holds 
.RE
.PP

.PP
Definition at line 128 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const \fBVector\fP< T, N\-1 > & v, const T & last)\fC [inline]\fP"

.PP
O(N) time\&. 
.PP
Definition at line 141 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const \fBVector\fP< T, N > & obj)\fC [inline]\fP"

.PP
Copies the contents of a \fC\fBVector\fP\fP into a new \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP A \fC\fBVector\fP\fP to clone 
.RE
.PP

.PP
Definition at line 152 of file Vector\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename T, Size N> T* \fBmc::Vector\fP< T, N >::begin ()\fC [inline]\fP"

.PP
Definition at line 200 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T* \fBmc::Vector\fP< T, N >::begin () const\fC [inline]\fP"

.PP
Definition at line 204 of file Vector\&.h\&.
.SS "template<typename T, Size N> T* \fBmc::Vector\fP< T, N >::end ()\fC [inline]\fP"

.PP
Definition at line 208 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T* \fBmc::Vector\fP< T, N >::end () const\fC [inline]\fP"

.PP
Definition at line 212 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T* \fBmc::Vector\fP< T, N >::flatten (T arr[N]) const\fC [inline]\fP"

.PP
Creates an array with the data of this \fC\fBVector\fP\fP, in O(N) time\&. 
.PP
\fBReturns:\fP
.RS 4
Pointer to \fCarr\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIarr\fP The array to fill 
.RE
.PP

.PP
Definition at line 258 of file Vector\&.h\&.
.SS "template<typename T, Size N> T& \fBmc::Vector\fP< T, N >::get (\fBIndex\fP i)\fC [inline]\fP"

.PP
Get the value at a position\&. Slower than \fCoperator[]\fP because it does bounds checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP \fCIndex\fP of the requested data, zero-indexed 
.RE
.PP
\fBReturns:\fP
.RS 4
The value located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP If \fCi\fP is greater than \fC\fBsize()\fP\fP 
.br
\fIIndexOutOfBounds\fP If \fCi\fP is less than 0 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 224 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T& \fBmc::Vector\fP< T, N >::get (\fBIndex\fP i) const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBget(Index)\fP,\fP in case a \fC\fBVector\fP\fP is declared \fCconst\fP 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP \fCIndex\fP of the requested data, zero-indexed 
.RE
.PP
\fBReturns:\fP
.RS 4
The \fCconst\fP value located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP If \fCi\fP is greater than \fC\fBsize()\fP\fP 
.br
\fIIndexOutOfBounds\fP If \fCi\fP is less than 0 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 236 of file Vector\&.h\&.
.SS "template<typename T, Size N> std::array< T, N>& \fBmc::Vector\fP< T, N >::getContents ()\fC [inline]\fP"

.PP
Retrieves the contents of this \fC\fBVector\fP\fP 
.PP
\fBReturns:\fP
.RS 4
An \fCstd::array\fP of this \fC\fBVector\fP\fP contents 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetContents(std::array<T,N>)\fP 
.RE
.PP

.PP
Definition at line 163 of file Vector\&.h\&.
.SS "template<typename T, Size N> const std::array< T, N>& \fBmc::Vector\fP< T, N >::getContents () const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBgetContents()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCconst std::array\fP of this \fCconst \fBVector\fP\fP contents 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetContents(std::array<T,N>)\fP 
.RE
.PP

.PP
Definition at line 172 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator!= (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares whether 2 \fCVectors\fP don't have the same values\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare \fCthis\fP against 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the 2 are not equal, \fCfalse\fP otherwise 
.RE
.PP
\fBSee also:\fP
.RS 4
operator==(const Vector<T,N>) const 
.PP
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 582 of file Vector\&.h\&.
.SS "template<typename T, Size N> virtual T& \fBmc::Vector\fP< T, N >::operator() (\fBIndex\fP i)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Retrieves content at a certain \fCIndex\fP, not zero indexed\&. Equal to
.PP
.nf
vector[i-1]

.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Not zero indexed \fCIndex\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Value at \fCi-1\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 328 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T& \fBmc::Vector\fP< T, N >::operator() (\fBIndex\fP i) const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBoperator()(Index)\fP\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Not zero indexed \fCIndex\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Value at \fCi-1\fP 
.RE
.PP

.PP
Definition at line 337 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator* (const \fBVector\fP< T, 3 > & right) const\fC [inline]\fP"

.PP
Multiplies 2 \fCVectors\fP together\&. This is done in O(N) time
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The product of the multiplication 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.RE
.PP

.PP
Definition at line 379 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator* (const T scalar) const\fC [inline]\fP"

.PP
Multiplies a \fC\fBVector\fP\fP by a scalar\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP What to multiply this \fC\fBVector\fP\fP by 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP scaled\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
operator*(const Vector&) const 
.RE
.PP

.PP
Definition at line 436 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator*= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Multiplies a \fC\fBVector\fP\fP by this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to multiply 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator+(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 483 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator*= (const T & scalar)\fC [inline]\fP"

.PP
Scales this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP How much to scale 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator*(const Vector<T,3>&) const\fP 
.PP
operator*(const T&) const 
.RE
.PP

.PP
Definition at line 531 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator+ (const \fBVector\fP< T, N > & right) const\fC [inline]\fP"

.PP
Adds 2 \fCVectors\fP together\&. This is done in o(N) time
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP that was created by adding 2 \fCVectors\fP together 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.RE
.PP

.PP
Definition at line 350 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator+ (const T scalar) const\fC [inline]\fP"

.PP
Translates a \fC\fBVector\fP\fP with a scalar\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP What to translate this \fC\fBVector\fP\fP by 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP translated\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
operator*(const Vector&) const 
.RE
.PP

.PP
Definition at line 408 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator+= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Adds a \fC\fBVector\fP\fP to this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to add 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator+(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 461 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator+= (const T & scalar)\fC [inline]\fP"

.PP
Translates this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP How much to translate by 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator*(const Vector<T,3>&) const\fP 
.PP
operator*(const T&) const 
.RE
.PP

.PP
Definition at line 507 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator\- (const \fBVector\fP< T, N > & right) const\fC [inline]\fP"

.PP
Subtracts 2 \fCVectors\fP together\&. This is done in O(N) time
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP that was created by subtracting 2 \fCVectors\fP together 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.RE
.PP

.PP
Definition at line 364 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator\- (const T scalar) const\fC [inline]\fP"

.PP
Translates a \fC\fBVector\fP\fP with a scalar\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP What to translate this \fC\fBVector\fP\fP by 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP translated\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
operator*(const Vector&) const 
.RE
.PP

.PP
Definition at line 422 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator\-= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Subtracts a \fC\fBVector\fP\fP from this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to subtract 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator-(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 472 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator\-= (const T & scalar)\fC [inline]\fP"

.PP
Translates this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP How much to translate by 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator*(const Vector<T,3>&) const\fP 
.PP
operator*(const T&) const 
.RE
.PP

.PP
Definition at line 519 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator/ (const \fBVector\fP< T, 3 > & right) const\fC [inline]\fP"

.PP
Divides 2 \fCVectors\fP together\&. This is done in O(N) time
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The quotient of 2 \fCVectors\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.RE
.PP

.PP
Definition at line 394 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator/ (const T scalar) const\fC [inline]\fP"

.PP
Divides a \fC\fBVector\fP\fP by a scalar\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP What to divided this \fC\fBVector\fP\fP by 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP scaled\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
operator*(const T&) const 
.RE
.PP

.PP
Definition at line 450 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator/= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Divides a \fC\fBVector\fP\fP by this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to divide 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator+(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 494 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator/= (const T & scalar)\fC [inline]\fP"

.PP
Divides this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP How much to divide by 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator*(const Vector<T,3>&) const\fP 
.PP
operator*(const T&) const 
.RE
.PP

.PP
Definition at line 543 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator< (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC<\fP operator on 2 \fCVectors\fP elements\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC<\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 635 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator<= (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC<=\fP operator on 2 \fCVectors\fP elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC<=\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 649 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator== (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares whether 2 \fCVectors\fP have the same values\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare \fCthis\fP against 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the 2 are equal, \fCfalse\fP otherwise 
.RE
.PP
\fBSee also:\fP
.RS 4
operator!=(const Vector<T,N>) const 
.PP
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 561 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator> (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC>\fP operator on 2 \fCVectors\fP elements\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC>\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 598 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator>= (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC>=\fP operator on 2 \fCVectors\fP elements\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC>=\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 619 of file Vector\&.h\&.
.SS "template<typename T, Size N> T& \fBmc::Vector\fP< T, N >::operator[] (\fBIndex\fP i)\fC [inline]\fP"

.PP
Retrieves the content at a certain \fCIndex\fP, zero indexed\&. This operator is faster than \fC\fBget(Index)\fP,\fP as it doesn't do bounds checking\&. However, accessing an invalid index will be undefined\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Where to retrieve the data 
.RE
.PP
\fBReturns:\fP
.RS 4
The data at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index) const\fP 
.RE
.PP

.PP
Definition at line 305 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T& \fBmc::Vector\fP< T, N >::operator[] (\fBIndex\fP i) const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBoperator[](Index)\fP\fP used if a \fC\fBVector\fP\fP is declared \fCconst\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Where to retrieve the data 
.RE
.PP
\fBReturns:\fP
.RS 4
The data at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 314 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::set (\fBIndex\fP position, T value)\fC [inline]\fP"

.PP
Set data at a certain position to equal a new value\&. Slower than \fCoperator[]\fP because it does bounds checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Where to put the new value, zero indexed\&. 
.br
\fIvalue\fP What to put in \fCposition\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP If \fCi\fP is greater than \fC\fBsize()\fP\fP 
.br
\fIIndexOutOfBounds\fP If \fCi\fP is less than 0 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 248 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::setContents (const std::array< T, N > contents)\fC [inline]\fP"

.PP
Copies the contents of an \fCstd::array\fP into this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcontents\fP An \fCstd::array\fP whose data will be dumped into this \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 179 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::setContents (const T arr[N])\fC [inline]\fP"

.PP
Copies the contents of an array into this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIarr\fP An equally sized array whose contents will cloned in this \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 186 of file Vector\&.h\&.
.SS "template<typename T, Size N> constexpr \fBSize\fP \fBmc::Vector\fP< T, N >::size () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Retrieves how many elements this \fC\fBVector\fP\fP holds\&. 
.PP
\fBReturns:\fP
.RS 4
How large this \fC\fBVector\fP\fP is 
.RE
.PP

.PP
Definition at line 196 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP<T, 1> \fBmc::Vector\fP< T, N >::w () const\fC [inline]\fP"

.PP
Definition at line 279 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP<T, 1> \fBmc::Vector\fP< T, N >::x () const\fC [inline]\fP"

.PP
Definition at line 265 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP<T, 2> \fBmc::Vector\fP< T, N >::xy () const\fC [inline]\fP"

.PP
Definition at line 284 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP<T, 3> \fBmc::Vector\fP< T, N >::xyz () const\fC [inline]\fP"

.PP
Definition at line 289 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP<T, 4> \fBmc::Vector\fP< T, N >::xyzw () const\fC [inline]\fP"

.PP
Definition at line 294 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP<T, 1> \fBmc::Vector\fP< T, N >::y () const\fC [inline]\fP"

.PP
Definition at line 269 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP<T, 1> \fBmc::Vector\fP< T, N >::z () const\fC [inline]\fP"

.PP
Definition at line 274 of file Vector\&.h\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<typename T, Size N> std::ostream& operator<< (std::ostream & output, const \fBVector\fP< T, N > & v)\fC [friend]\fP"

.PP
Operator used to output to \fCstd::cout\fP\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIoutput\fP \fCstd::ostream\fP the \fC\fBMatrix\fP\fP was inserted into 
.br
\fIv\fP \fC\fBMatrix\fP\fP which will be printed 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCoutput\fP for chaining 
.RE
.PP

.PP
Definition at line 661 of file Vector\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "template<typename T, Size N> T \fBmc::Vector\fP< T, N >::content[N]\fC [protected]\fP"

.PP
Definition at line 673 of file Vector\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
