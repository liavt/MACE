.TH "mc::Vector< T, N >" 3 "Fri Nov 25 2016" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::Vector< T, N > \- 1-dimensional vector class that supports mathmatical operations\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Vector\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVector\fP ()"
.br
.RI "\fIDefault constructor\&. \fP"
.ti -1c
.RI "\fBVector\fP (const T arr[N])"
.br
.RI "\fIConsructs a \fC\fBVector\fP\fP from the contents of an array\&. \fP"
.ti -1c
.RI "\fBVector\fP (const std::array< T, N > &contents)"
.br
.RI "\fIConsructs a \fC\fBVector\fP\fP from the contents of an \fCstd::array\fP\&. \fP"
.ti -1c
.RI "\fBVector\fP (const std::initializer_list< T > args)"
.br
.ti -1c
.RI "\fBVector\fP (const \fBVector\fP &obj)"
.br
.RI "\fICopies the contents of a \fC\fBVector\fP\fP into a new \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "std::array< T, N > & \fBgetContents\fP ()"
.br
.RI "\fIRetrieves the contents of this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "const std::array< T, N > & \fBgetContents\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetContents()\fP\fP \fP"
.ti -1c
.RI "void \fBsetContents\fP (const std::array< T, N > contents)"
.br
.RI "\fICopies the contents of an \fCstd::array\fP into this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "void \fBsetContents\fP (const T arr[N])"
.br
.RI "\fICopies the contents of an array into this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "constexpr \fBSize\fP \fBsize\fP () const "
.br
.RI "\fIRetrieves how many elements this \fC\fBVector\fP\fP holds\&. \fP"
.ti -1c
.RI "T & \fBget\fP (\fBIndex\fP i)"
.br
.RI "\fIGet the value at a position\&. \fP"
.ti -1c
.RI "const T & \fBget\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fC\fBget(Index)\fP,\fP in case a \fC\fBVector\fP\fP is declared \fCconst\fP \fP"
.ti -1c
.RI "void \fBset\fP (\fBIndex\fP position, T value)"
.br
.RI "\fISet data at a certain position to equal a new value\&. \fP"
.ti -1c
.RI "const T * \fBflatten\fP (T arr[N]) const "
.br
.RI "\fICreates an array with the data of this \fC\fBVector\fP\fP, in O(N) time\&. \fP"
.ti -1c
.RI "T & \fBoperator[]\fP (\fBIndex\fP i)"
.br
.RI "\fIRetrieves the content at a certain \fCIndex\fP, zero indexed\&. \fP"
.ti -1c
.RI "const T & \fBoperator[]\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fC\fBoperator[](Index)\fP\fP used if a \fC\fBVector\fP\fP is declared \fCconst\fP\&. \fP"
.ti -1c
.RI "virtual T & \fBoperator()\fP (\fBIndex\fP i)"
.br
.RI "\fIRetrieves content at a certain \fCIndex\fP, not zero indexed\&. \fP"
.ti -1c
.RI "const T & \fBoperator()\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fC\fBoperator()(Index)\fP\fP\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator+\fP (const \fBVector\fP< T, N > &right) const "
.br
.RI "\fIAdds 2 \fCVectors\fP together\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator\-\fP (const \fBVector\fP< T, N > &right) const "
.br
.RI "\fISubtracts 2 \fCVectors\fP together\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator*\fP (const \fBVector\fP< T, 3 > &right) const "
.br
.RI "\fICalculates the cross product of 2 \fCVectors\fP \fP"
.ti -1c
.RI "T \fBoperator%\fP (const \fBVector\fP< T, 3 > &right) const "
.br
.RI "\fICalculates the dot product of 2 \fCVectors\fP \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator*\fP (const T scalar) const "
.br
.RI "\fIMultiplies a \fC\fBVector\fP\fP by a scalar\&. \fP"
.ti -1c
.RI "\fBVector\fP \fBoperator/\fP (const T scalar) const "
.br
.RI "\fIDivides a \fC\fBVector\fP\fP by a scalar\&. \fP"
.ti -1c
.RI "void \fBoperator+=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fIAdds a \fC\fBVector\fP\fP to this one\&. \fP"
.ti -1c
.RI "void \fBoperator\-=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fISubtracts a \fC\fBVector\fP\fP from this one\&. \fP"
.ti -1c
.RI "void \fBoperator*=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fIMultiplies a \fC\fBVector\fP\fP by this one\&. \fP"
.ti -1c
.RI "void \fBoperator/=\fP (const \fBVector\fP< T, N > &right)"
.br
.RI "\fIDivides a \fC\fBVector\fP\fP by this one\&. \fP"
.ti -1c
.RI "void \fBoperator*=\fP (const T &scalar)"
.br
.RI "\fIScales this \fC\fBVector\fP\fP \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares whether 2 \fCVectors\fP have the same values\&. \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares whether 2 \fCVectors\fP don't have the same values\&. \fP"
.ti -1c
.RI "bool \fBoperator>\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC>\fP operator on 2 \fCVectors\fP elements\&. \fP"
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC>=\fP operator on 2 \fCVectors\fP elements\&. \fP"
.ti -1c
.RI "bool \fBoperator<\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC<\fP operator on 2 \fCVectors\fP elements\&. \fP"
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBVector\fP< T, N > &other) const "
.br
.RI "\fICompares the \fC<=\fP operator on 2 \fCVectors\fP elements\&. \fP"
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::array< T, N > \fBcontent\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &output, const \fBVector\fP< T, N > &v)"
.br
.RI "\fIOperator used to output to \fCstd::cout\fP\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T, Size N>
.br
struct mc::Vector< T, N >"
1-dimensional vector class that supports mathmatical operations\&. 

\fCVectors\fP can be added, subtracted, and multiplied\&. by other \fCVectors\fP of equal width\&. Additionally, they can also be operated by a \fC\fBMatrix\fP\fP of equal width\&. \fCVectors\fP CANNOT be divided\&. 
.PP
\fC\fBVector\fP\fP math is done by adding the adjacent values of both vectors together\&. For example, we want to add these 2 \fCVectors\fP together: 
.PP
.nf
left = [55,42,-12,23]

right = [3,7,5,9]

result = left + right

.fi
.PP
 The result would be every value across from eachother added together, as so: 
.PP
.nf
result = [left[1]+right[1],left[2]+right[2],left[3]+right[3],left[4]+right[4]]

.fi
.PP
 or 
.PP
.nf
result = [58,49,-7,32]

.fi
.PP
 Multiplication, and subtraction are the same concept\&. To do math with MACE, all you need to do is to use the mathmatical operators\&. 
.PP
Examples: 
.PP
.nf
Vector<int,3> vector = Vector<int,3>();//Create a Vector of 3 ints

int array[] = {1,2,3};
vector = array;//Generate Vector from array

vector\&.get(i);//Get int from position i
vector[i];//get int from position i

vector\&.set(i,v);//Set int at position i to equal v
vector[i]=v;//set int at position i to equal v

vector\&.size() //Get how many elements the Vector has

//Iterate through a Vector:
for(Index i =0;i<vector\&.size();i++){
    int value = vector[i];
}

.fi
.PP
 
.PP
\fBSee also:\fP
.RS 4
\fBMatrix\fP 
.RE
.PP
\fBTemplate Parameters:\fP
.RS 4
\fIT\fP what the \fC\fBVector\fP\fP is made of and calculates with\&. 
.br
\fIN\fP width of the \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 76 of file Vector\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP ()\fC [inline]\fP"

.PP
Default constructor\&. Constructs an empty \fC\fBVector\fP\fP 
.PP
Definition at line 81 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const T arr[N])\fC [inline]\fP"

.PP
Consructs a \fC\fBVector\fP\fP from the contents of an array\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarr\fP An equally-sized array whose contents will be filled into a \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 89 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const std::array< T, N > & contents)\fC [inline]\fP"

.PP
Consructs a \fC\fBVector\fP\fP from the contents of an \fCstd::array\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcontents\fP An equally-sized \fCstd::array\fP whose contents will be filled into a \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 99 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const std::initializer_list< T > args)\fC [inline]\fP"

.PP
Definition at line 103 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBmc::Vector\fP< T, N >::\fBVector\fP (const \fBVector\fP< T, N > & obj)\fC [inline]\fP"

.PP
Copies the contents of a \fC\fBVector\fP\fP into a new \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIobj\fP A \fC\fBVector\fP\fP to clone 
.RE
.PP

.PP
Definition at line 117 of file Vector\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "template<typename T, Size N> const T* \fBmc::Vector\fP< T, N >::flatten (T arr[N]) const\fC [inline]\fP"

.PP
Creates an array with the data of this \fC\fBVector\fP\fP, in O(N) time\&. 
.PP
\fBReturns:\fP
.RS 4
Pointer to \fCarr\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIarr\fP The array to fill 
.RE
.PP

.PP
Definition at line 204 of file Vector\&.h\&.
.SS "template<typename T, Size N> T& \fBmc::Vector\fP< T, N >::get (\fBIndex\fP i)\fC [inline]\fP"

.PP
Get the value at a position\&. Slower than \fCoperator[]\fP because it does bounds checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP \fCIndex\fP of the requested data, zero-indexed 
.RE
.PP
\fBReturns:\fP
.RS 4
The value located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP If \fCi\fP is greater than \fC\fBsize()\fP\fP 
.br
\fIIndexOutOfBounds\fP If \fCi\fP is less than 0 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 170 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T& \fBmc::Vector\fP< T, N >::get (\fBIndex\fP i) const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBget(Index)\fP,\fP in case a \fC\fBVector\fP\fP is declared \fCconst\fP 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP \fCIndex\fP of the requested data, zero-indexed 
.RE
.PP
\fBReturns:\fP
.RS 4
The \fCconst\fP value located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP If \fCi\fP is greater than \fC\fBsize()\fP\fP 
.br
\fIIndexOutOfBounds\fP If \fCi\fP is less than 0 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 182 of file Vector\&.h\&.
.SS "template<typename T, Size N> std::array< T, N>& \fBmc::Vector\fP< T, N >::getContents ()\fC [inline]\fP"

.PP
Retrieves the contents of this \fC\fBVector\fP\fP 
.PP
\fBReturns:\fP
.RS 4
An \fCstd::array\fP of this \fC\fBVector\fP\fP contents 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetContents(std::array<T,N>)\fP 
.RE
.PP

.PP
Definition at line 124 of file Vector\&.h\&.
.SS "template<typename T, Size N> const std::array< T, N>& \fBmc::Vector\fP< T, N >::getContents () const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBgetContents()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCconst std::array\fP of this \fCconst \fBVector\fP\fP contents 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetContents(std::array<T,N>)\fP 
.RE
.PP

.PP
Definition at line 133 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator!= (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares whether 2 \fCVectors\fP don't have the same values\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare \fCthis\fP against 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the 2 are not equal, \fCfalse\fP otherwise 
.RE
.PP
\fBSee also:\fP
.RS 4
operator==(const Vector<T,N>) const 
.PP
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 445 of file Vector\&.h\&.
.SS "template<typename T, Size N> T \fBmc::Vector\fP< T, N >::operator% (const \fBVector\fP< T, 3 > & right) const\fC [inline]\fP"

.PP
Calculates the dot product of 2 \fCVectors\fP This is done in o(N) time
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The dot product 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.PP
cross(const Vector&, const Vector&) 
.PP
operator*(const T) 
.PP
operator*(const Vector&) 
.RE
.PP

.PP
Definition at line 326 of file Vector\&.h\&.
.SS "template<typename T, Size N> virtual T& \fBmc::Vector\fP< T, N >::operator() (\fBIndex\fP i)\fC [inline]\fP, \fC [virtual]\fP"

.PP
Retrieves content at a certain \fCIndex\fP, not zero indexed\&. Equal to
.PP
.nf
vector[i-1]

.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Not zero indexed \fCIndex\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Value at \fCi-1\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 240 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T& \fBmc::Vector\fP< T, N >::operator() (\fBIndex\fP i) const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBoperator()(Index)\fP\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Not zero indexed \fCIndex\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Value at \fCi-1\fP 
.RE
.PP

.PP
Definition at line 249 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator* (const \fBVector\fP< T, 3 > & right) const\fC [inline]\fP"

.PP
Calculates the cross product of 2 \fCVectors\fP 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The cross product 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.PP
cross(const Vector&, const Vector&) 
.PP
operator*(const T) 
.PP
operator%(const Vector&) 
.RE
.PP

.PP
Definition at line 295 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator* (const T scalar) const\fC [inline]\fP"

.PP
Multiplies a \fC\fBVector\fP\fP by a scalar\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP What to multiply this \fC\fBVector\fP\fP by 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP scaled\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
operator*(const Vector&) const 
.RE
.PP

.PP
Definition at line 343 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator*= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Multiplies a \fC\fBVector\fP\fP by this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to multiply 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator+(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 390 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator*= (const T & scalar)\fC [inline]\fP"

.PP
Scales this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP How much to scale 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator*(const Vector<T,3>&) const\fP 
.PP
\fBoperator*(const T) const\fP 
.RE
.PP

.PP
Definition at line 408 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator+ (const \fBVector\fP< T, N > & right) const\fC [inline]\fP"

.PP
Adds 2 \fCVectors\fP together\&. This is done in o(N) time
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP that was created by adding 2 \fCVectors\fP together 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.RE
.PP

.PP
Definition at line 262 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator+= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Adds a \fC\fBVector\fP\fP to this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to add 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator+(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 372 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator\- (const \fBVector\fP< T, N > & right) const\fC [inline]\fP"

.PP
Subtracts 2 \fCVectors\fP together\&. This is done in o(N) time
.PP
\fBParameters:\fP
.RS 4
\fIright\fP Another \fC\fBVector\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP that was created by subtracting 2 \fCVectors\fP together 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBVector\fP for an explanation of \fC\fBVector\fP\fP \fBmath\fP 
.RE
.PP

.PP
Definition at line 278 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator\-= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Subtracts a \fC\fBVector\fP\fP from this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to subtract 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator-(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 381 of file Vector\&.h\&.
.SS "template<typename T, Size N> \fBVector\fP \fBmc::Vector\fP< T, N >::operator/ (const T scalar) const\fC [inline]\fP"

.PP
Divides a \fC\fBVector\fP\fP by a scalar\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIscalar\fP What to divided this \fC\fBVector\fP\fP by 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fC\fBVector\fP\fP scaled\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
operator*(const T&) const 
.RE
.PP

.PP
Definition at line 359 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::operator/= (const \fBVector\fP< T, N > & right)\fC [inline]\fP"

.PP
Divides a \fC\fBVector\fP\fP by this one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIright\fP A \fC\fBVector\fP\fP to divide 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator+(const Vector<T,N>&) const\fP 
.RE
.PP

.PP
Definition at line 399 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator< (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC<\fP operator on 2 \fCVectors\fP elements\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC<\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 498 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator<= (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC<=\fP operator on 2 \fCVectors\fP elements\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC<=\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 512 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator== (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares whether 2 \fCVectors\fP have the same values\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare \fCthis\fP against 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the 2 are equal, \fCfalse\fP otherwise 
.RE
.PP
\fBSee also:\fP
.RS 4
operator!=(const Vector<T,N>) const 
.PP
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 424 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator> (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC>\fP operator on 2 \fCVectors\fP elements\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC>\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>=(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 461 of file Vector\&.h\&.
.SS "template<typename T, Size N> bool \fBmc::Vector\fP< T, N >::operator>= (const \fBVector\fP< T, N > & other) const\fC [inline]\fP"

.PP
Compares the \fC>=\fP operator on 2 \fCVectors\fP elements\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP A \fC\fBVector\fP\fP to compare against 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the \fC>=\fP operator on each element 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator<(const Vector&) const\fP 
.PP
\fBoperator>(const Vector&) const\fP 
.PP
\fBoperator<=(const Vector&) const\fP 
.PP
\fBoperator==(const Vector&) const\fP 
.PP
\fBoperator!=(const Vector&) const\fP 
.RE
.PP

.PP
Definition at line 482 of file Vector\&.h\&.
.SS "template<typename T, Size N> T& \fBmc::Vector\fP< T, N >::operator[] (\fBIndex\fP i)\fC [inline]\fP"

.PP
Retrieves the content at a certain \fCIndex\fP, zero indexed\&. This operator is faster than \fC\fBget(Index)\fP,\fP as it doesn't do bounds checking\&. However, accessing an invalid index will be undefined\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Where to retrieve the data 
.RE
.PP
\fBReturns:\fP
.RS 4
The data at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index) const\fP 
.RE
.PP

.PP
Definition at line 217 of file Vector\&.h\&.
.SS "template<typename T, Size N> const T& \fBmc::Vector\fP< T, N >::operator[] (\fBIndex\fP i) const\fC [inline]\fP"

.PP
\fCconst\fP version of \fC\fBoperator[](Index)\fP\fP used if a \fC\fBVector\fP\fP is declared \fCconst\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Where to retrieve the data 
.RE
.PP
\fBReturns:\fP
.RS 4
The data at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 226 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::set (\fBIndex\fP position, T value)\fC [inline]\fP"

.PP
Set data at a certain position to equal a new value\&. Slower than \fCoperator[]\fP because it does bounds checking\&. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Where to put the new value, zero indexed\&. 
.br
\fIvalue\fP What to put in \fCposition\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP If \fCi\fP is greater than \fC\fBsize()\fP\fP 
.br
\fIIndexOutOfBounds\fP If \fCi\fP is less than 0 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBoperator[](Index)\fP 
.RE
.PP

.PP
Definition at line 194 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::setContents (const std::array< T, N > contents)\fC [inline]\fP"

.PP
Copies the contents of an \fCstd::array\fP into this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcontents\fP An \fCstd::array\fP whose data will be dumped into this \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 140 of file Vector\&.h\&.
.SS "template<typename T, Size N> void \fBmc::Vector\fP< T, N >::setContents (const T arr[N])\fC [inline]\fP"

.PP
Copies the contents of an array into this \fC\fBVector\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIarr\fP An equally sized array whose contents will cloned in this \fC\fBVector\fP\fP 
.RE
.PP

.PP
Definition at line 147 of file Vector\&.h\&.
.SS "template<typename T, Size N> constexpr \fBSize\fP \fBmc::Vector\fP< T, N >::size () const\fC [inline]\fP"

.PP
Retrieves how many elements this \fC\fBVector\fP\fP holds\&. 
.PP
\fBReturns:\fP
.RS 4
How large this \fC\fBVector\fP\fP is 
.RE
.PP

.PP
Definition at line 157 of file Vector\&.h\&.
.SH "Friends And Related Function Documentation"
.PP 
.SS "template<typename T, Size N> std::ostream& operator<< (std::ostream & output, const \fBVector\fP< T, N > & v)\fC [friend]\fP"

.PP
Operator used to output to \fCstd::cout\fP\&. This is done in O(N) time 
.PP
\fBParameters:\fP
.RS 4
\fIoutput\fP \fCstd::ostream\fP the \fC\fBMatrix\fP\fP was inserted into 
.br
\fIv\fP \fC\fBMatrix\fP\fP which will be printed 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCoutput\fP for chaining 
.RE
.PP

.PP
Definition at line 524 of file Vector\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "template<typename T, Size N> std::array<T, N> \fBmc::Vector\fP< T, N >::content\fC [protected]\fP"

.PP
Definition at line 536 of file Vector\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
