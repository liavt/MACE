.TH "mc::gfx::Text" 3 "Sat Apr 8 2017" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::gfx::Text \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Entity2D\&.h>\fP
.PP
Inherits \fBmc::gfx::Entity2D\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBEntityProperty\fP : Byte { \fBDEAD\fP = 0, \fBDISABLED\fP = 1, \fBINIT\fP = 2, \fBDIRTY\fP = 3, \fBMAINTAIN_X\fP = 4, \fBMAINTAIN_Y\fP = 5, \fBMAINTAIN_WIDTH\fP = 6, \fBMAINTAIN_HEIGHT\fP = 7, \fBDEFAULT_PROPERTIES\fP = 0b00000000 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBText\fP (const std::string &t, const \fBFont\fP &f=\fBFont\fP())"
.br
.ti -1c
.RI "\fBText\fP (const std::wstring &t=L'', const \fBFont\fP &f=\fBFont\fP())"
.br
.ti -1c
.RI "\fB~Text\fP ()=default"
.br
.ti -1c
.RI "void \fBsetText\fP (const std::wstring &newText)"
.br
.ti -1c
.RI "std::wstring & \fBgetText\fP ()"
.br
.ti -1c
.RI "const std::wstring & \fBgetText\fP () const "
.br
.ti -1c
.RI "void \fBsetFont\fP (const \fBFont\fP &f)"
.br
.ti -1c
.RI "\fBFont\fP & \fBgetFont\fP ()"
.br
.ti -1c
.RI "const \fBFont\fP & \fBgetFont\fP () const "
.br
.ti -1c
.RI "const std::vector< \fBLetter\fP > & \fBgetLetters\fP () const "
.br
.ti -1c
.RI "void \fBsetVerticalAlign\fP (const \fBVerticalAlign\fP align)"
.br
.ti -1c
.RI "const \fBVerticalAlign\fP \fBgetVerticalAlign\fP () const "
.br
.ti -1c
.RI "void \fBsetHorizontalAlign\fP (\fBHorizontalAlign\fP align)"
.br
.ti -1c
.RI "const \fBHorizontalAlign\fP \fBgetHorizontalAlign\fP () const "
.br
.ti -1c
.RI "void \fBsetTexture\fP (const \fBColorAttachment\fP &tex)"
.br
.ti -1c
.RI "\fBColorAttachment\fP & \fBgetTexture\fP ()"
.br
.ti -1c
.RI "const \fBColorAttachment\fP & \fBgetTexture\fP () const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBText\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBText\fP &other) const "
.br
.ti -1c
.RI "\fBogl::UniformBuffer\fP & \fBgetBuffer\fP ()"
.br
.ti -1c
.RI "const \fBogl::UniformBuffer\fP & \fBgetBuffer\fP () const "
.br
.ti -1c
.RI "void \fBsetBuffer\fP (const \fBogl::UniformBuffer\fP &newBuffer)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBEntity2D\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBGraphicsEntity\fP &other) const  noexcept"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBEntity\fP &other) const  noexcept"
.br
.RI "\fICompares if 2 \fCEntities\fP have the same children, parent, and properties\&. \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBEntity2D\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBGraphicsEntity\fP &other) const  noexcept"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBEntity\fP &other) const  noexcept"
.br
.RI "\fICompares if 2 \fCEntities\fP don't have the same children, parent, and properties\&. \fP"
.ti -1c
.RI "void \fBclean\fP () final"
.br
.ti -1c
.RI "void \fBinit\fP () final"
.br
.RI "\fIShould be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.init()\fP\fP is called\&. \fP"
.ti -1c
.RI "void \fBdestroy\fP () final"
.br
.RI "\fIShould be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.destroy()\fP\fP is called\&. \fP"
.ti -1c
.RI "float \fBgetOpacity\fP ()"
.br
.ti -1c
.RI "const float \fBgetOpacity\fP () const "
.br
.ti -1c
.RI "void \fBsetOpacity\fP (const float f)"
.br
.ti -1c
.RI "const std::vector< \fBEntity\fP * > & \fBgetChildren\fP () const "
.br
.RI "\fIGets all of this \fC\fBEntity\fP's\fP children\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (const \fBEntity\fP &e)"
.br
.RI "\fIRemoves a child\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (const \fBEntity\fP *e)"
.br
.RI "\fIRemoves a child\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (\fBIndex\fP index)"
.br
.RI "\fIRemoves a child via location\&. \fP"
.ti -1c
.RI "bool \fBhasChild\fP (\fBEntity\fP &e) const "
.br
.RI "\fIChecks to see if this \fC\fBEntity\fP\fP contains an \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "void \fBclearChildren\fP ()"
.br
.RI "\fIRemoves EVERY \fC\fBEntity\fP\fP from this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "\fBEntity\fP & \fBoperator[]\fP (\fBIndex\fP i)"
.br
.RI "\fIAccess an \fC\fBEntity\fP\fP\&. \fP"
.ti -1c
.RI "const \fBEntity\fP & \fBoperator[]\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fBoperator[](Index i)\fP \fP"
.ti -1c
.RI "\fBEntity\fP & \fBgetChild\fP (\fBIndex\fP i)"
.br
.RI "\fIRetrieves a child at a certain index\&. \fP"
.ti -1c
.RI "const \fBEntity\fP & \fBgetChild\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fBgetChild(Index)\fP \fP"
.ti -1c
.RI "int \fBindexOf\fP (const \fBEntity\fP &e) const "
.br
.RI "\fIFinds the location of an \fC\fBEntity\fP\fP in this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const "
.br
.RI "\fIChecks whether this \fC\fBEntity\fP\fP has any children\&. \fP"
.ti -1c
.RI "std::vector< \fBEntity\fP * >::iterator \fBbegin\fP ()"
.br
.RI "\fIRetrieves the beginning of the children of this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "std::vector< \fBEntity\fP * >::iterator \fBend\fP ()"
.br
.RI "\fIRetrieves the end of the children of this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "\fBSize\fP \fBsize\fP () const "
.br
.RI "\fICalculates the amount of children this \fC\fBEntity\fP\fP has\&. \fP"
.ti -1c
.RI "\fBEntityProperties\fP & \fBgetProperties\fP ()"
.br
.RI "\fIRetrieves the \fC\fBEntity\fP's\fP properties as a \fCByteField\fP \fP"
.ti -1c
.RI "const \fBEntityProperties\fP & \fBgetProperties\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetProperties()\fP\fP \fP"
.ti -1c
.RI "void \fBsetProperties\fP (\fBEntityProperties\fP &b)"
.br
.RI "\fISet the properties for this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "bool \fBgetProperty\fP (const \fBByte\fP position) const "
.br
.RI "\fIRetrieve the value of a property\&. \fP"
.ti -1c
.RI "void \fBsetProperty\fP (const \fBByte\fP position, const bool value)"
.br
.RI "\fISet a property to be \fCtrue\fP or \fCfalse\fP\&. \fP"
.ti -1c
.RI "\fBTransformMatrix\fP & \fBgetTransformation\fP ()"
.br
.ti -1c
.RI "const \fBTransformMatrix\fP & \fBgetTransformation\fP () const "
.br
.ti -1c
.RI "void \fBsetTransformation\fP (\fBTransformMatrix\fP &trans)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBtranslate\fP (float x, float y, float z=0\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBrotate\fP (float x, float y, float z=0\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBscale\fP (float x, float y, float z=1\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP *const \fBgetParent\fP ()"
.br
.RI "\fIRetrieve this \fCEntitys\fP parent `Entity\&. \fP"
.ti -1c
.RI "const \fBEntity\fP *const \fBgetParent\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetParent()\fP\fP \fP"
.ti -1c
.RI "bool \fBhasParent\fP () const "
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBEntity\fP &e)"
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBEntity\fP *e)"
.br
.ti -1c
.RI "void \fBaddComponent\fP (\fBComponent\fP *action)"
.br
.ti -1c
.RI "void \fBaddComponent\fP (\fBComponent\fP &action)"
.br
.ti -1c
.RI "std::vector< \fBComponent\fP * > \fBgetComponents\fP ()"
.br
.ti -1c
.RI "const float & \fBgetWidth\fP () const "
.br
.ti -1c
.RI "float & \fBgetWidth\fP ()"
.br
.ti -1c
.RI "void \fBsetWidth\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetHeight\fP () const "
.br
.ti -1c
.RI "float & \fBgetHeight\fP ()"
.br
.ti -1c
.RI "void \fBsetHeight\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetDepth\fP () const "
.br
.ti -1c
.RI "float & \fBgetDepth\fP ()"
.br
.ti -1c
.RI "void \fBsetDepth\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetX\fP () const "
.br
.ti -1c
.RI "float & \fBgetX\fP ()"
.br
.ti -1c
.RI "void \fBsetX\fP (const float &newX)"
.br
.ti -1c
.RI "const float & \fBgetY\fP () const "
.br
.ti -1c
.RI "float & \fBgetY\fP ()"
.br
.ti -1c
.RI "void \fBsetY\fP (const float &newY)"
.br
.ti -1c
.RI "const float & \fBgetZ\fP () const "
.br
.ti -1c
.RI "float & \fBgetZ\fP ()"
.br
.ti -1c
.RI "void \fBsetZ\fP (const float &newY)"
.br
.ti -1c
.RI "const \fBEntity\fP * \fBgetRoot\fP () const "
.br
.RI "\fIRetrieves the top most parent (known as the 'root\&.') \fP"
.ti -1c
.RI "\fBEntity\fP * \fBgetRoot\fP ()"
.br
.RI "\fIRetrieves the top most parent (known as the 'root\&.') \fP"
.ti -1c
.RI "\fBMetrics\fP \fBgetMetrics\fP () const "
.br
.ti -1c
.RI "void \fBreset\fP ()"
.br
.ti -1c
.RI "void \fBmakeDirty\fP ()"
.br
.RI "\fIMakes this \fC\fBEntity\fP\fP dirty and root dirty\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBonInit\fP () override final"
.br
.RI "\fIWhen \fC\fBEntity\&.init()\fP\fP is called, \fC\fBonInit()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonUpdate\fP () override final"
.br
.RI "\fIWhen \fC\fBEntity\&.update()\fP\fP is called, \fC\fBonUpdate()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonRender\fP () override final"
.br
.RI "\fIWhen \fC\fBEntity\&.render()\fP\fP is called, \fC\fBonRender()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonDestroy\fP () override final"
.br
.RI "\fIWhen \fC\fBEntity\&.destroy()\fP\fP is called, \fC\fBonDestroy()\fP\fP is called on all of it's children\&. \fP"
.ti -1c
.RI "void \fBonClean\fP () override final"
.br
.ti -1c
.RI "virtual void \fBupdate\fP ()"
.br
.RI "\fIShould be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.update()\fP\fP is called\&. \fP"
.ti -1c
.RI "virtual void \fBrender\fP ()"
.br
.RI "\fIShould be called by a \fC\fBEntity\fP\fP when the graphical \fCWindow\fP clears the frame\&. \fP"
.ti -1c
.RI "virtual void \fBhover\fP ()"
.br
.ti -1c
.RI "virtual void \fBonHover\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBogl::UniformBuffer\fP \fBbuffer\fP = \fBogl::UniformBuffer\fP()"
.br
.ti -1c
.RI "std::vector< \fBEntity\fP * > \fBchildren\fP = std::vector<\fBEntity\fP*>()"
.br
.RI "\fI\fCstd::vector\fP of this \fC\fBEntity\fP\\'s\fP children\&. \fP"
.ti -1c
.RI "\fBTransformMatrix\fP \fBtransformation\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBBug\fP
.RS 4
newline with vertical align doesnt really work 
.RE
.PP

.PP
Definition at line 350 of file Entity2D\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBmc::gfx::Entity::EntityProperty\fP : \fBByte\fP\fC [inherited]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDEAD \fP\fP
Bit location representing whether an \fC\fBEntity\fP\fP is dead\&. If \fCtrue,\fP any \fBEntity\fP holding it will remove it and call \fCkill()\fP 
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(unsigned int) 
.RE
.PP

.TP
\fB\fIDISABLED \fP\fP
Property defining if an \fC\fBEntity\fP\fP can be updated and rendered\&. If this is \fCtrue\fP, \fC\fBEntity::update()\fP\fP and \fC\fBEntity::render()\fP\fP will not be called by it's parent\&. 
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(unsigned int) 
.RE
.PP

.TP
\fB\fIINIT \fP\fP
Flag representing whether an \fBEntity\fP's \fBinit()\fP function has been called\&. If \fBdestroy()\fP or \fBupdate()\fP is called and this is \fCfalse\fP, an \fCInitializationError\fP is thrown\&. 
.PP
If \fBinit()\fP is called and this is \fCtrue\fP, an \fCInitializationError\fP is thrown\&. 
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(unsigned int) 
.RE
.PP

.TP
\fB\fIDIRTY \fP\fP
Flag representing whether this \fC\fBEntity\fP\fP is dirty and it's positions needs to be recalculated\&. This will become true under the following conditions:
.IP "\(bu" 2
The \fC\fBEntity\fP\fP has been changed\&. Assume that any non-const function other than \fBrender()\fP and \fBupdate()\fP will trigger this condition\&.
.IP "\(bu" 2
The window is resized, moved, or created 
.PP
.PP
Other classes that inherit \fC\fBEntity\fP\fP can also set this to true via \fBEntity::setProperty(Byte, bool)\fP 
.PP
When an \fC\fBEntity\fP\fP becomes dirty, it will propogate up the tree\&. It's parent will become dirty, it's parent will become dirty, etc\&. This will continue until it reaches the highest level \fC\fBEntity\fP\fP, which is usually the \fCGraphicsContext\fP\&. From there, it will decide what to do based on it's \fC\fBEntity::DIRTY\fP\fP flag\&. 
.PP
Certain \fCGraphicsContexts\fP may only render when something is dirty, heavily increasing performance in applications with little moving objects\&. 
.PP
Additionally, an \fC\fBEntity\fP\fP that is considered dirty will have it's sslBuffer updated on the GPU side\&. 
.TP
\fB\fIMAINTAIN_X \fP\fP
Flag representing whether an \fBEntity\fP's X position should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_Y\fP 
.PP
\fBEntity::MAINTAIN_WIDTH\fP 
.PP
\fBEntity::MAINTAIN_HEIGHT\fP 
.RE
.PP

.TP
\fB\fIMAINTAIN_Y \fP\fP
Flag representing whether an \fBEntity\fP's Y position should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_X\fP 
.PP
\fBEntity::MAINTAIN_WIDTH\fP 
.PP
\fBEntity::MAINTAIN_HEIGHT\fP 
.PP
WindowModule::setResizable(bool) 
.RE
.PP

.TP
\fB\fIMAINTAIN_WIDTH \fP\fP
Flag representing whether an \fBEntity\fP's width should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_X\fP 
.PP
\fBEntity::MAINTAIN_Y\fP 
.PP
\fBEntity::MAINTAIN_HEIGHT\fP 
.PP
WindowModule::setResizable(bool) 
.RE
.PP

.TP
\fB\fIMAINTAIN_HEIGHT \fP\fP
Flag representing whether an \fBEntity\fP's height should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_X\fP 
.PP
\fBEntity::MAINTAIN_Y\fP 
.PP
\fBEntity::MAINTAIN_WIDTH\fP 
.PP
WindowModule::setResizable(bool) 
.RE
.PP

.TP
\fB\fIDEFAULT_PROPERTIES \fP\fP
.PP
Definition at line 208 of file Entity\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "mc::gfx::Text::Text (const std::string & t, const \fBFont\fP & f = \fC\fBFont\fP()\fP)"

.SS "mc::gfx::Text::Text (const std::wstring & t = \fCL''\fP, const \fBFont\fP & f = \fC\fBFont\fP()\fP)"

.SS "mc::gfx::Text::~Text ()\fC [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void mc::gfx::Entity::addChild (\fBEntity\fP & e)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::addChild (\fBEntity\fP * e)\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::addComponent (\fBComponent\fP * action)\fC [inherited]\fP"

.SS "void mc::gfx::Entity::addComponent (\fBComponent\fP & action)\fC [inherited]\fP"

.PP

.SS "std::vector<\fBEntity\fP*>::iterator mc::gfx::Entity::begin ()\fC [inherited]\fP"

.PP
Retrieves the beginning of the children of this \fC\fBEntity\fP\fP 
.PP
\fBReturns:\fP
.RS 4
Pointer to the first \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::end()\fP 
.PP
\fBEntity::size()\fP 
.RE
.PP

.SS "void mc::gfx::GraphicsEntity::clean ()\fC [final]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Entity\fP\&.
.SS "void mc::gfx::Entity::clearChildren ()\fC [inherited]\fP"

.PP
Removes EVERY \fC\fBEntity\fP\fP from this \fC\fBEntity\fP\fP 
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.PP
\fBEntity::size()\fP 
.PP
\fBEntity::removeChild(Index)\fP 
.PP
\fBEntity::removeChild(const Entity&)\fP 
.RE
.PP

.SS "void mc::gfx::GraphicsEntity::destroy ()\fC [final]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Should be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.destroy()\fP\fP is called\&. Calls \fC\fBonDestroy()\fP\fP\&. Sets \fC\fBEntity::INIT\fP\fP to be false 
.PP
Overriding this function is dangerous\&. Only do it if you know what you are doing\&. Instead, override \fC\fBonDestroy()\fP\fP 
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.br
\fIInitializationError\fP If the property \fC\fBEntity::INIT\fP\fP is false, meaning \fC\fBinit()\fP\fP was not called\&. 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Entity\fP\&.
.SS "std::vector<\fBEntity\fP*>::iterator mc::gfx::Entity::end ()\fC [inherited]\fP"

.PP
Retrieves the end of the children of this \fC\fBEntity\fP\fP 
.PP
\fBReturns:\fP
.RS 4
End of the last \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::begin()\fP 
.PP
\fBEntity::size()\fP 
.RE
.PP

.SS "\fBogl::UniformBuffer\fP& mc::gfx::Entity2D::getBuffer ()\fC [inherited]\fP"

.PP

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBogl::UniformBuffer\fP& mc::gfx::Entity2D::getBuffer () const\fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::getChild (\fBIndex\fP i)\fC [inherited]\fP"

.PP
Retrieves a child at a certain index\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index of the \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP if \fCi\fP is less than \fC0\fP or greater than \fBsize()\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::operator[]\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "const \fBEntity\fP& mc::gfx::Entity::getChild (\fBIndex\fP i) const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fBgetChild(Index)\fP 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP \fCIndex\fP of the \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP if \fCi\fP is less than \fC0\fP or greater than \fBsize()\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::operator[]\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "const std::vector<\fBEntity\fP*>& mc::gfx::Entity::getChildren () const\fC [inherited]\fP"

.PP
Gets all of this \fC\fBEntity\fP's\fP children\&. 
.PP
\fBReturns:\fP
.RS 4
an \fCstd::vector\fP with all children of this \fC\fBEntity\fP\fP 
.RE
.PP

.SS "std::vector<\fBComponent\fP*> mc::gfx::Entity::getComponents ()\fC [inherited]\fP"

.SS "const float& mc::gfx::Entity::getDepth () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getDepth ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "\fBFont\fP& mc::gfx::Text::getFont ()"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBFont\fP& mc::gfx::Text::getFont () const"

.SS "const float& mc::gfx::Entity::getHeight () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getHeight ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBHorizontalAlign\fP mc::gfx::Text::getHorizontalAlign () const"

.SS "const std::vector<\fBLetter\fP>& mc::gfx::Text::getLetters () const"

.SS "\fBMetrics\fP mc::gfx::Entity::getMetrics () const\fC [inherited]\fP"

.SS "float mc::gfx::GraphicsEntity::getOpacity ()\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const float mc::gfx::GraphicsEntity::getOpacity () const\fC [inherited]\fP"

.SS "\fBEntity\fP* const mc::gfx::Entity::getParent ()\fC [inherited]\fP"

.PP
Retrieve this \fCEntitys\fP parent `Entity\&. \fC @return A\fP\fBEntity\fP\fCwhich contains\fPthis` 
.PP
\fBSee also:\fP
.RS 4
Entity::hasChild(const Entity&) const; 
.RE
.PP

.SS "const \fBEntity\fP* const mc::gfx::Entity::getParent () const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fC\fBgetParent()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fC\fBEntity\fP\fP which contains \fCthis\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::hasChild(const Entity&) const; 
.RE
.PP

.SS "\fBEntityProperties\fP& mc::gfx::Entity::getProperties ()\fC [inherited]\fP"

.PP
Retrieves the \fC\fBEntity\fP's\fP properties as a \fCByteField\fP 
.PP
\fBReturns:\fP
.RS 4
The current properties belonging to this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getProperties() const\fP 
.PP
Entity::setProperties(ByteField&) 
.PP
Entity::getProperty(Index) const 
.PP
Entity::setProperty(Index, bool) 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBEntityProperties\fP& mc::gfx::Entity::getProperties () const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fC\fBgetProperties()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
The current properties belonging to this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::setProperties(ByteField&) 
.PP
Entity::getProperty(Index) const 
.PP
Entity::setProperty(Index, bool) 
.RE
.PP

.SS "bool mc::gfx::Entity::getProperty (const \fBByte\fP position) const\fC [inherited]\fP"

.PP
Retrieve the value of a property\&. By default, they are all false\&. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Location of the property based on a constant 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP or \fCfalse\fP based on the postition 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::setProperty(Index, bool) 
.PP
\fBEntity::getProperties()\fP 
.PP
Entity::setProperties(ByteField&) 
.RE
.PP

.SS "const \fBEntity\fP* mc::gfx::Entity::getRoot () const\fC [inherited]\fP"

.PP
Retrieves the top most parent (known as the 'root\&.') The root does not have any parent\&. 
.PP
If this \fC\fBEntity\fP\fP does not have any parent, returns \fCthis\fP 
.PP
\fBReturns:\fP
.RS 4
The root \fC\fBEntity\fP\fP of which this \fC\fBEntity\fP\fP belongs to\&. 
.RE
.PP

.SS "\fBEntity\fP* mc::gfx::Entity::getRoot ()\fC [inherited]\fP"

.PP
Retrieves the top most parent (known as the 'root\&.') The root does not have any parent\&. 
.PP
If this \fC\fBEntity\fP\fP does not have any parent, returns \fCthis\fP 
.PP
\fBReturns:\fP
.RS 4
The root \fC\fBEntity\fP\fP of which this \fC\fBEntity\fP\fP belongs to\&. 
.RE
.PP

.SS "std::wstring& mc::gfx::Text::getText ()"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const std::wstring& mc::gfx::Text::getText () const"

.SS "\fBColorAttachment\fP& mc::gfx::Text::getTexture ()"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBColorAttachment\fP& mc::gfx::Text::getTexture () const"

.SS "\fBTransformMatrix\fP& mc::gfx::Entity::getTransformation ()\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBTransformMatrix\fP& mc::gfx::Entity::getTransformation () const\fC [inherited]\fP"

.SS "const \fBVerticalAlign\fP mc::gfx::Text::getVerticalAlign () const"

.SS "const float& mc::gfx::Entity::getWidth () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getWidth ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "const float& mc::gfx::Entity::getX () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getX ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "const float& mc::gfx::Entity::getY () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getY ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "const float& mc::gfx::Entity::getZ () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getZ ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "bool mc::gfx::Entity::hasChild (\fBEntity\fP & e) const\fC [inherited]\fP"

.PP
Checks to see if this \fC\fBEntity\fP\fP contains an \fC\fBEntity\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP Reference to an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCfalse\fP if this \fC\fBEntity\fP\fP doesn't contain the referenced \fC\fBEntity\fP\fP, \fCtrue\fP otherwise 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::indexOf(const Entity& ) const\fP 
.RE
.PP

.SS "bool mc::gfx::Entity::hasParent () const\fC [inherited]\fP"

.SS "virtual void mc::gfx::Entity::hover ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.SS "int mc::gfx::Entity::indexOf (const \fBEntity\fP & e) const\fC [inherited]\fP"

.PP
Finds the location of an \fC\fBEntity\fP\fP in this \fC\fBEntity\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP Reference to an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Location of \fCe,\fP or -1 if \fCe\fP is not a child of this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::operator[]\fP 
.PP
\fBEntity::getChild(Index)\fP 
.RE
.PP

.SS "void mc::gfx::GraphicsEntity::init ()\fC [final]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Should be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.init()\fP\fP is called\&. Calls \fC\fBonInit()\fP\fP 
.PP
Overriding this function is dangerous\&. Only do it if you know what you are doing\&. Instead, override \fC\fBonInit()\fP\fP 
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.br
\fIInitializationError\fP If the property \fC\fBEntity::INIT\fP\fP is true, meaning \fC\fBinit()\fP\fP has already been called\&. 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Entity\fP\&.
.SS "bool mc::gfx::Entity::isEmpty () const\fC [inherited]\fP"

.PP
Checks whether this \fC\fBEntity\fP\fP has any children\&. 
.PP
\fBReturns:\fP
.RS 4
If \fBEntity::size()\fP is 0 
.RE
.PP

.SS "void mc::gfx::Entity::makeDirty ()\fC [inherited]\fP"

.PP
Makes this \fC\fBEntity\fP\fP dirty and root dirty\&. Should be used over \fCsetProperty(Entity::DIRTY,true)\fP as it updaets the root parent\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getRoot()\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Text::onClean ()\fC [final]\fP, \fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Entity\fP\&.
.SS "void mc::gfx::Text::onDestroy ()\fC [final]\fP, \fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.destroy()\fP\fP is called, \fC\fBonDestroy()\fP\fP is called on all of it's children\&. 
.PP
\fBSee also:\fP
.RS 4
\fBMACE::destroy()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "virtual void mc::gfx::Entity::onHover ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::Button\fP\&.
.SS "void mc::gfx::Text::onInit ()\fC [final]\fP, \fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.init()\fP\fP is called, \fC\fBonInit()\fP\fP is called on all of it's children\&. 
.PP
\fBSee also:\fP
.RS 4
\fBMACE::init()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "void mc::gfx::Text::onRender ()\fC [final]\fP, \fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.render()\fP\fP is called, \fC\fBonRender()\fP\fP is called on all of it's children\&. 
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "void mc::gfx::Text::onUpdate ()\fC [final]\fP, \fC [override]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
When \fC\fBEntity\&.update()\fP\fP is called, \fC\fBonUpdate()\fP\fP is called on all of it's children\&. 
.PP
\fBSee also:\fP
.RS 4
\fBMACE::update()\fP 
.RE
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.PP
Implements \fBmc::gfx::Entity\fP\&.
.SS "bool mc::gfx::Entity2D::operator!= (const \fBEntity2D\fP & other) const\fC [inherited]\fP"

.SS "bool mc::gfx::Text::operator!= (const \fBText\fP & other) const"

.SS "bool mc::gfx::Entity::operator!= (const \fBEntity\fP & other) const\fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Compares if 2 \fCEntities\fP don't have the same children, parent, and properties\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP An \fC\fBEntity\fP\fP compare this one to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCfalse\fP if they are equal 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetProperties() const\fP 
.PP
\fBgetParent() const\fP 
.PP
\fBgetChildren() const\fP 
.PP
operator== 
.RE
.PP

.SS "bool mc::gfx::GraphicsEntity::operator!= (const \fBGraphicsEntity\fP & other) const\fC [noexcept]\fP, \fC [inherited]\fP"

.SS "bool mc::gfx::Entity2D::operator== (const \fBEntity2D\fP & other) const\fC [inherited]\fP"

.SS "bool mc::gfx::Text::operator== (const \fBText\fP & other) const"

.SS "bool mc::gfx::Entity::operator== (const \fBEntity\fP & other) const\fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Compares if 2 \fCEntities\fP have the same children, parent, and properties\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP An \fC\fBEntity\fP\fP compare this one to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if they are equal 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetProperties() const\fP 
.PP
\fBgetParent() const\fP 
.PP
\fBgetChildren() const\fP 
.PP
operator!= 
.RE
.PP

.SS "bool mc::gfx::GraphicsEntity::operator== (const \fBGraphicsEntity\fP & other) const\fC [noexcept]\fP, \fC [inherited]\fP"

.SS "\fBEntity\fP& mc::gfx::Entity::operator[] (\fBIndex\fP i)\fC [inherited]\fP"

.PP
Access an \fC\fBEntity\fP\fP\&. This is different than \fC\fBgetChild()\fP\fP because \fCoperator[]\fP doesn't do bounds checking\&. Accessing an invalid location will result in a memory error\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Location of an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getChild(Index)\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "const \fBEntity\fP& mc::gfx::Entity::operator[] (\fBIndex\fP i) const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fBoperator[](Index i)\fP 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Location of an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getChild(Index) const\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "void mc::gfx::Entity::removeChild (const \fBEntity\fP & e)\fC [inherited]\fP"

.PP
Removes a child\&. This function calls no member functions of the argument, meaning that 
.PP
\fBExceptions:\fP
.RS 4
\fIObjectNotFoundInArray\fP if this \fC\fBEntity\fP\fP does not contain the argument returns \fCfalse\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIe\fP an \fC\fBEntity\fP\fP to remove 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::removeChild(Index)\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::removeChild (const \fBEntity\fP * e)\fC [inherited]\fP"

.PP
Removes a child\&. This function calls no member functions of the argument, meaning that 
.PP
\fBExceptions:\fP
.RS 4
\fIObjectNotFoundInArray\fP if this \fC\fBEntity\fP\fP does not contain the argument returns \fCfalse\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIe\fP an \fC\fBEntity\fP\fP to remove 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::removeChild(Index)\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fINullPointerError\fP if the argument is \fCnullptr\fP 
.RE
.PP

.SS "void mc::gfx::Entity::removeChild (\fBIndex\fP index)\fC [inherited]\fP"

.PP
Removes a child via location\&. 
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP if the index is less than 0 or greater than \fBsize()\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP Index of the \fC\fBEntity\fP\fP to be removed 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::indexOf(const Entity&) const\fP 
.PP
\fBEntity::removeChild(const Entity&)\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "virtual void mc::gfx::Entity::render ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Should be called by a \fC\fBEntity\fP\fP when the graphical \fCWindow\fP clears the frame\&. Overriding this function is dangerous\&. Only do it if you know what you are doing\&. Instead, override \fC\fBonRender()\fP\fP 
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::update()\fP 
.RE
.PP

.SS "void mc::gfx::Entity::reset ()\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::rotate (float x, float y, float z = \fC0\&.0f\fP)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::scale (float x, float y, float z = \fC1\&.0f\fP)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity2D::setBuffer (const \fBogl::UniformBuffer\fP & newBuffer)\fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setDepth (const float & s)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Text::setFont (const \fBFont\fP & f)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setHeight (const float & s)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Text::setHorizontalAlign (\fBHorizontalAlign\fP align)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::GraphicsEntity::setOpacity (const float f)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setProperties (\fBEntityProperties\fP & b)\fC [inherited]\fP"

.PP
Set the properties for this \fC\fBEntity\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP New \fC\fBEntity\fP\fP properties 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getProperties()\fP 
.PP
Entity::getProperty(Index) const 
.PP
Entity::setProperty(Index, bool) 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setProperty (const \fBByte\fP position, const bool value)\fC [inherited]\fP"

.PP
Set a property to be \fCtrue\fP or \fCfalse\fP\&. By default, they are all false\&. 
.PP
\fBNote:\fP
.RS 4
Do not use \fCsetProperty(Entity::DIRTY, true)\fP\&. Use Entity::makeDity() instead\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Location of the property based on a constant 
.br
\fIvalue\fP Whether it is \fCtrue\fP or \fCfalse\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(Index) const 
.PP
\fBEntity::getProperties()\fP 
.PP
Entity::setProperties(ByteField&) 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Text::setText (const std::wstring & newText)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Text::setTexture (const \fBColorAttachment\fP & tex)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setTransformation (\fBTransformMatrix\fP & trans)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Text::setVerticalAlign (const \fBVerticalAlign\fP align)"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setWidth (const float & s)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setX (const float & newX)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setY (const float & newY)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setZ (const float & newY)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "\fBSize\fP mc::gfx::Entity::size () const\fC [inherited]\fP"

.PP
Calculates the amount of children this \fC\fBEntity\fP\fP has\&. 
.PP
\fBReturns:\fP
.RS 4
Size of this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::isEmpty()\fP 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::translate (float x, float y, float z = \fC0\&.0f\fP)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "virtual void mc::gfx::Entity::update ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Should be called a by \fC\fBEntity\fP\fP when \fC\fBMACE\&.update()\fP\fP is called\&. Calls \fC\fBonUpdate()\fP\fP\&. 
.PP
Overriding this function is dangerous\&. Only do it if you know what you are doing\&. Instead, override \fC\fBonUpdate()\fP\fP 
.PP
\fBExceptions:\fP
.RS 4
\fIInitializationError\fP If the property \fC\fBEntity::INIT\fP\fP is false, meaning \fC\fBinit()\fP\fP was not called\&. 
.RE
.PP

.PP
Reimplemented in \fBmc::os::WindowModule\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBogl::UniformBuffer\fP mc::gfx::Entity2D::buffer = \fBogl::UniformBuffer\fP()\fC [protected]\fP, \fC [inherited]\fP"

.PP
Definition at line 66 of file Entity2D\&.h\&.
.SS "std::vector<\fBEntity\fP*> mc::gfx::Entity::children = std::vector<\fBEntity\fP*>()\fC [protected]\fP, \fC [inherited]\fP"

.PP
\fCstd::vector\fP of this \fC\fBEntity\fP\\'s\fP children\&. Use of this variable directly is unrecommended\&. Use \fC\fBaddChild()\fP\fP or \fC\fBremoveChild()\fP\fP instead\&. 
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.PP
Definition at line 751 of file Entity\&.h\&.
.SS "\fBTransformMatrix\fP mc::gfx::Entity::transformation\fC [protected]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.PP
Definition at line 756 of file Entity\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
