.TH "mc::Color" 3 "Wed Feb 1 2017" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::Color \- Represents a color in the RGBA space\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Color\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBColor\fP (const int red, const int green, const int blue, const int alpha=255) noexcept"
.br
.ti -1c
.RI "\fBColor\fP (const \fBByte\fP red, const \fBByte\fP green, const \fBByte\fP blue, const \fBByte\fP alpha=255) noexcept"
.br
.ti -1c
.RI "\fBColor\fP (const float red, const float green, const float blue, const float alpha=1\&.0f) noexcept"
.br
.RI "\fICreates a \fC\fBColor\fP\fP from specified values\&. \fP"
.ti -1c
.RI "\fBColor\fP (const std::array< float, 4 > &values)"
.br
.RI "\fICreates a \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. \fP"
.ti -1c
.RI "\fBColor\fP (const \fBColor\fP &copy) noexcept"
.br
.RI "\fIClones a \fC\fBColor\fP\fP, coying it's color values into a new one\&. \fP"
.ti -1c
.RI "\fBColor\fP () noexcept"
.br
.RI "\fIDefault constructor\&. \fP"
.ti -1c
.RI "\fBColor\fP \fBdarken\fP () const "
.br
.RI "\fICreates a new \fC\fBColor\fP\fP that is slightly darker\&. \fP"
.ti -1c
.RI "\fBColor\fP \fBlighten\fP () const "
.br
.RI "\fICreates a new \fC\fBColor\fP\fP that is slightly lighter\&. \fP"
.ti -1c
.RI "\fBByte\fP \fBgetRed\fP () const "
.br
.RI "\fIRetrieves the red component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "\fBByte\fP \fBgetGreen\fP () const "
.br
.RI "\fIRetrieves the green component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "\fBByte\fP \fBgetBlue\fP () const "
.br
.RI "\fIRetrieves the blue component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "\fBByte\fP \fBgetAlpha\fP () const "
.br
.RI "\fIRetrieves the alpha component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "void \fBsetRed\fP (const \fBByte\fP &\fBr\fP)"
.br
.RI "\fISet the red value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetGreen\fP (const \fBByte\fP &\fBg\fP)"
.br
.RI "\fISet the green value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetBlue\fP (const \fBByte\fP &\fBb\fP)"
.br
.RI "\fISet the blue value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetAlpha\fP (const \fBByte\fP &\fBa\fP)"
.br
.RI "\fISet the alpha value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetValues\fP (const std::array< float, 4 > &rgba)"
.br
.RI "\fISets the RGB values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. \fP"
.ti -1c
.RI "void \fBsetValues\fP (const std::array< float, 3 > &rgb)"
.br
.RI "\fISets the values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. \fP"
.ti -1c
.RI "std::array< float, 4 > \fBgetValues\fP () const "
.br
.RI "\fIRetrieves the RGBA values in \fCstd::array\fP \fP"
.ti -1c
.RI "const float * \fBflatten\fP (float arr[4]) const "
.br
.RI "\fICreates an array with the data of this \fC\fBColor\fP\fP, in O(N) time\&. \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 \fC\fBColors\fP\fP \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 \fC\fBColors\fP\fP \fP"
.ti -1c
.RI "bool \fBoperator>\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 '\fBColors\fP'\&. \fP"
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 '\fBColors\fP'\&. \fP"
.ti -1c
.RI "bool \fBoperator<\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 '\fBColors\fP'\&. \fP"
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 '\fBColors\fP'\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "float \fBr\fP"
.br
.RI "\fI\fBColor\fP component, represented as a \fCfloat\fP\&. \fP"
.ti -1c
.RI "float \fBg\fP"
.br
.ti -1c
.RI "float \fBb\fP"
.br
.ti -1c
.RI "float \fBa\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Represents a color in the RGBA space\&. 

Values are stored as a \fCfloat\fP between 0 and 1, where 1 is the brightest\&. Values can optionally be added as a \fCByte\fP from 0 to 255\&. 
.PP
Note that conversion from a \fCByte\fP to a \fCfloat\fP (and vice-versa) is not 100% accurate and may produce slightly different results on different processors\&. 
.PP
Examples: 
.PP
.nf
Color color = {1\&.0f,1\&.0f,1\&.0f,1\&.0f};//create the color white

float red = color\&.r;//retrive the red componenet, as a float from 0\&.0 to 1\&.0
float green = color\&.g;//retrive the green componenet, as a float from 0\&.0 to 1\&.0
float blue = color\&.b;//retrive the blue componenet, as a float from 0\&.0 to 1\&.0
float alpha = color\&.a;//retrive the alpha componenet, as a float from 0\&.0 to 1\&.0

red = color\&.getRed();//retrieve the red component as a byte from 0 to 255
green = color\&.getGreen();//retrieve the red component as a byte from 0 to 255
blue = color\&.getBlue();//retrieve the red component as a byte from 0 to 255
alpha = color\&.getAlpha();//retrieve the red component as a byte from 0 to 255

color\&.r = 0\&.5f;//set the red component to be 0\&.5f
color\&.setRed(127); //set the red component to be 0\&.5f as a Byte from 0 to 255

.fi
.PP
 
.PP
Definition at line 41 of file Color\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "mc::Color::Color (const int red, const int green, const int blue, const int alpha = \fC255\fP)\fC [explicit]\fP, \fC [noexcept]\fP"

.SS "mc::Color::Color (const \fBByte\fP red, const \fBByte\fP green, const \fBByte\fP blue, const \fBByte\fP alpha = \fC255\fP)\fC [explicit]\fP, \fC [noexcept]\fP"

.SS "mc::Color::Color (const float red, const float green, const float blue, const float alpha = \fC1\&.0f\fP)\fC [noexcept]\fP"

.PP
Creates a \fC\fBColor\fP\fP from specified values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIred\fP The red component from 0\&.0 to 1\&.0, where 1\&.0 is the most red\&. 
.br
\fIgreen\fP The red component from 0\&.0 to 1\&.0, where 1\&.0 is the most red\&. 
.br
\fIblue\fP The red component from 0\&.0 to 1\&.0, where 1\&.0 is the most red\&. 
.br
\fIalpha\fP The alpha component from 0\&.0 to 1\&.0, where 1\&.0 is opaque and 0\&.0 is transparent\&. By default, this parameter is 1\&.0 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<float,4>) 
.RE
.PP

.SS "mc::Color::Color (const std::array< float, 4 > & values)"

.PP
Creates a \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalues\fP An array where the first element is red, the second is green, etc 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<Byte,4>) 
.PP
\fBColor(float,float,float,float)\fP 
.PP
\fBsetValues\fP(std::array<float,4> 
.RE
.PP

.SS "mc::Color::Color (const \fBColor\fP & copy)\fC [noexcept]\fP"

.PP
Clones a \fC\fBColor\fP\fP, coying it's color values into a new one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcopy\fP A \fC\fBColor\fP\fP to copy 
.RE
.PP

.SS "mc::Color::Color ()\fC [noexcept]\fP"

.PP
Default constructor\&. Constructs a \fC\fBColor\fP\fP with all of it's color values as \fC0\fP, or black\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBColor\fP mc::Color::darken () const"

.PP
Creates a new \fC\fBColor\fP\fP that is slightly darker\&. Due to rounding, \fCcolor\&.darken() != color\&.darken()\&.\fBlighten()\fP\fP 
.PP
The alpha is not affected 
.PP
\fBReturns:\fP
.RS 4
A darker \fC\fBColor\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBColor::lighten() const\fP 
.RE
.PP

.SS "const float* mc::Color::flatten (float arr[4]) const"

.PP
Creates an array with the data of this \fC\fBColor\fP\fP, in O(N) time\&. 
.PP
\fBReturns:\fP
.RS 4
Pointer to \fCarr\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIarr\fP The array to fill 
.RE
.PP

.SS "\fBByte\fP mc::Color::getAlpha () const"

.PP
Retrieves the alpha component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is fully opaque, and 0 is transparent 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBa\fP 
.RE
.PP

.SS "\fBByte\fP mc::Color::getBlue () const"

.PP
Retrieves the blue component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBb\fP 
.RE
.PP

.SS "\fBByte\fP mc::Color::getGreen () const"

.PP
Retrieves the green component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBg\fP 
.RE
.PP

.SS "\fBByte\fP mc::Color::getRed () const"

.PP
Retrieves the red component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBr\fP 
.RE
.PP

.SS "std::array<float, 4> mc::Color::getValues () const"

.PP
Retrieves the RGBA values in \fCstd::array\fP 
.PP
\fBReturns:\fP
.RS 4
An array where the first element is red, the second value is green, etc 
.RE
.PP

.SS "\fBColor\fP mc::Color::lighten () const"

.PP
Creates a new \fC\fBColor\fP\fP that is slightly lighter\&. Due to rounding, \fCcolor\&.lighten() != color\&.lighten()\&.\fBdarken()\fP\fP 
.PP
The alpha is not affected 
.PP
\fBReturns:\fP
.RS 4
A lighter \fC\fBColor\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBColor::darken() const\fP 
.RE
.PP

.SS "bool mc::Color::operator!= (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 \fC\fBColors\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether the 2 \fC\fBColors\fP\fP don't have the same RGBA 
.RE
.PP
\fBSee also:\fP
.RS 4
operator==(Color&) const 
.RE
.PP

.SS "bool mc::Color::operator< (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 '\fBColors\fP'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fC\fBColors\fP\fP r, g, b, and a values\&. 
.RE
.PP

.SS "bool mc::Color::operator<= (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 '\fBColors\fP'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fC\fBColors\fP\fP r, g, b, and a values\&. 
.RE
.PP

.SS "bool mc::Color::operator== (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 \fC\fBColors\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether the 2 \fC\fBColors\fP\fP have the same RGBA 
.RE
.PP
\fBSee also:\fP
.RS 4
operator!=(Color&) const 
.RE
.PP

.SS "bool mc::Color::operator> (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 '\fBColors\fP'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fC\fBColors\fP\fP r, g, b, and a values\&. 
.RE
.PP

.SS "bool mc::Color::operator>= (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 '\fBColors\fP'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fC\fBColors\fP\fP r, g, b, and a values\&. 
.RE
.PP

.SS "void mc::Color::setAlpha (const \fBByte\fP & a)"

.PP
Set the alpha value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A \fCByte\fP from 0 to 255, where 255 is opaque 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetAlpha()\fP 
.PP
\fBa\fP 
.RE
.PP

.SS "void mc::Color::setBlue (const \fBByte\fP & b)"

.PP
Set the blue value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetBlue()\fP 
.PP
\fBb\fP 
.RE
.PP

.SS "void mc::Color::setGreen (const \fBByte\fP & g)"

.PP
Set the green value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIg\fP A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetGreen()\fP 
.PP
\fBg\fP 
.RE
.PP

.SS "void mc::Color::setRed (const \fBByte\fP & r)"

.PP
Set the red value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetRed()\fP 
.PP
\fBr\fP 
.RE
.PP

.SS "void mc::Color::setValues (const std::array< float, 4 > & rgba)"

.PP
Sets the RGB values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. The alpha is unchanged 
.PP
\fBParameters:\fP
.RS 4
\fIrgba\fP An array where the first element is red, the second is green, etc 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<Byte,4>) 
.PP
Color(std::array<float,4>) 
.PP
\fBColor(float,float,float,float)\fP 
.PP
setValues(std::array<float,4>) 
.RE
.PP

.SS "void mc::Color::setValues (const std::array< float, 3 > & rgb)"

.PP
Sets the values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrgb\fP An array where the first element is red, the second is green, etc 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<Byte,4>) 
.PP
Color(std::array<Byte,4>) 
.PP
\fBColor(float,float,float,float)\fP 
.PP
setValues(std::array<float,3>) 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "float mc::Color::a"

.PP
Definition at line 47 of file Color\&.h\&.
.SS "float mc::Color::b"

.PP
Definition at line 47 of file Color\&.h\&.
.SS "float mc::Color::g"

.PP
Definition at line 47 of file Color\&.h\&.
.SS "float mc::Color::r"

.PP
\fBColor\fP component, represented as a \fCfloat\fP\&. It is from 0\&.0 to 1\&.0, where 1\&.0 is the brightest it can get\&. 
.PP
Definition at line 47 of file Color\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
