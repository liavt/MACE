.TH "mc::Color" 3 "Sat Dec 17 2016" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::Color \- Represents a color in the RGBA space\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Color\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBColor\fP (const float &red, const float &green, const float &blue, const float &alpha=1\&.0f)"
.br
.RI "\fICreates a \fC\fBColor\fP\fP from specified values\&. \fP"
.ti -1c
.RI "\fBColor\fP (const std::array< float, 4 > &values)"
.br
.RI "\fICreates a \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. \fP"
.ti -1c
.RI "\fBColor\fP (const \fBColor\fP &copy)"
.br
.RI "\fIClones a \fC\fBColor\fP\fP, coying it's color values into a new one\&. \fP"
.ti -1c
.RI "\fBColor\fP () noexcept"
.br
.RI "\fIDefault constructor\&. \fP"
.ti -1c
.RI "\fBByte\fP \fBgetRed\fP () const "
.br
.RI "\fIRetrieves the red component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "\fBByte\fP \fBgetGreen\fP () const "
.br
.RI "\fIRetrieves the green component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "\fBByte\fP \fBgetBlue\fP () const "
.br
.RI "\fIRetrieves the blue component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "\fBByte\fP \fBgetAlpha\fP () const "
.br
.RI "\fIRetrieves the alpha component of this \fC\fBColor\fP\fP \fP"
.ti -1c
.RI "void \fBsetRed\fP (const \fBByte\fP &\fBr\fP)"
.br
.RI "\fISet the red value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetGreen\fP (const \fBByte\fP &\fBg\fP)"
.br
.RI "\fISet the green value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetBlue\fP (const \fBByte\fP &\fBb\fP)"
.br
.RI "\fISet the blue value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetAlpha\fP (const \fBByte\fP &\fBa\fP)"
.br
.RI "\fISet the alpha value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. \fP"
.ti -1c
.RI "void \fBsetValues\fP (const std::array< float, 4 > &rgba)"
.br
.RI "\fISets the RGB values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. \fP"
.ti -1c
.RI "void \fBsetValues\fP (const std::array< float, 3 > &rgb)"
.br
.RI "\fISets the values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. \fP"
.ti -1c
.RI "std::array< float, 4 > \fBgetValues\fP () const "
.br
.RI "\fIRetrieves the RGBA values in \fCstd::array\fP \fP"
.ti -1c
.RI "bool \fBoperator==\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 \fCColors\fP \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 \fCColors\fP \fP"
.ti -1c
.RI "bool \fBoperator>\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 'Colors'\&. \fP"
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 'Colors'\&. \fP"
.ti -1c
.RI "bool \fBoperator<\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 'Colors'\&. \fP"
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBColor\fP &other) const "
.br
.RI "\fICompares the color values of 2 'Colors'\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBByte\fP \fBconvertFloatToRGBA\fP (const float &color)"
.br
.RI "\fIConverts a \fC\fBColor\fP\fP component represented as a \fCfloat\fP to a \fCByte\fP \fP"
.ti -1c
.RI "static float \fBconvertRGBAToFloat\fP (const \fBByte\fP &color)"
.br
.RI "\fIConverts a \fC\fBColor\fP\fP component represented as a \fCByte\fP to a \fCfloat\fP \fP"
.ti -1c
.RI "static float \fBtrimFloat\fP (const float &color)"
.br
.RI "\fIChecks the bounds of a \fCfloat\fP making sure that it is not greater than 1,0 or less than 0\&.0\&. \fP"
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "float \fBr\fP"
.br
.RI "\fI\fBColor\fP component, represented as a \fCfloat\fP\&. \fP"
.ti -1c
.RI "float \fBg\fP"
.br
.ti -1c
.RI "float \fBb\fP"
.br
.ti -1c
.RI "float \fBa\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Represents a color in the RGBA space\&. 

Values are stored as a \fCfloat\fP between 0 and 1, where 1 is the brightest\&. Values can optionally be added as a \fCByte\fP from 0 to 255\&. 
.PP
Note that conversion from a \fCByte\fP to a \fCfloat\fP (and vice-versa) is not 100% accurate and may produce slightly different results on different processors\&. 
.PP
Examples: 
.PP
.nf
Color color = {1\&.0f,1\&.0f,1\&.0f,1\&.0f};//create the color white

float red = color\&.r;//retrive the red componenet, as a float from 0\&.0 to 1\&.0
float green = color\&.g;//retrive the green componenet, as a float from 0\&.0 to 1\&.0
float blue = color\&.b;//retrive the blue componenet, as a float from 0\&.0 to 1\&.0
float alpha = color\&.a;//retrive the alpha componenet, as a float from 0\&.0 to 1\&.0

red = color\&.getRed();//retrieve the red component as a byte from 0 to 255
green = color\&.getGreen();//retrieve the red component as a byte from 0 to 255
blue = color\&.getBlue();//retrieve the red component as a byte from 0 to 255
alpha = color\&.getAlpha();//retrieve the red component as a byte from 0 to 255

color\&.r = 0\&.5f;//set the red component to be 0\&.5f
color\&.setRed(127); //set the red component to be 0\&.5f as a Byte from 0 to 255

.fi
.PP
 
.PP
Definition at line 41 of file Color\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "mc::Color::Color (const float & red, const float & green, const float & blue, const float & alpha = \fC1\&.0f\fP)"

.PP
Creates a \fC\fBColor\fP\fP from specified values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIred\fP The red component from 0\&.0 to 1\&.0, where 1\&.0 is the most red\&. 
.br
\fIgreen\fP The red component from 0\&.0 to 1\&.0, where 1\&.0 is the most red\&. 
.br
\fIblue\fP The red component from 0\&.0 to 1\&.0, where 1\&.0 is the most red\&. 
.br
\fIalpha\fP The alpha component from 0\&.0 to 1\&.0, where 1\&.0 is opaque and 0\&.0 is transparent\&. By default, this parameter is 1\&.0 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<float,4>) 
.RE
.PP

.SS "mc::Color::Color (const std::array< float, 4 > & values)"

.PP
Creates a \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalues\fP An array where the first element is red, the second is green, etc 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<Byte,4>) 
.PP
Color(float,float,float,float) 
.PP
\fBsetValues\fP(std::array<float,4> 
.RE
.PP

.SS "mc::Color::Color (const \fBColor\fP & copy)"

.PP
Clones a \fC\fBColor\fP\fP, coying it's color values into a new one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcopy\fP A \fC\fBColor\fP\fP to copy 
.RE
.PP

.SS "mc::Color::Color ()\fC [noexcept]\fP"

.PP
Default constructor\&. Constructs a \fC\fBColor\fP\fP with all of it's color values as \fC0\fP, or black\&. 
.SH "Member Function Documentation"
.PP 
.SS "static \fBByte\fP mc::Color::convertFloatToRGBA (const float & color)\fC [static]\fP"

.PP
Converts a \fC\fBColor\fP\fP component represented as a \fCfloat\fP to a \fCByte\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcolor\fP A \fCfloat\fP from 0\&.0 to 1\&.0 
.RE
.PP
\fBReturns:\fP
.RS 4
An equal \fCByte\fP from 0 to 255 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.RE
.PP

.SS "static float mc::Color::convertRGBAToFloat (const \fBByte\fP & color)\fC [static]\fP"

.PP
Converts a \fC\fBColor\fP\fP component represented as a \fCByte\fP to a \fCfloat\fP 
.PP
\fBReturns:\fP
.RS 4
An equal \fCfloat\fP from 0\&.0 to 1\&.0 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIcolor\fP A\fCByte\fP from 0 to 255 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.RE
.PP

.SS "\fBByte\fP mc::Color::getAlpha () const"

.PP
Retrieves the alpha component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is fully opaque, and 0 is transparent 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBa\fP 
.RE
.PP

.SS "\fBByte\fP mc::Color::getBlue () const"

.PP
Retrieves the blue component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBb\fP 
.RE
.PP

.SS "\fBByte\fP mc::Color::getGreen () const"

.PP
Retrieves the green component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBg\fP 
.RE
.PP

.SS "\fBByte\fP mc::Color::getRed () const"

.PP
Retrieves the red component of this \fC\fBColor\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertFloatToRGBA(float) 
.PP
convertRGBAToFloat(Byte) 
.PP
\fBr\fP 
.RE
.PP

.SS "std::array<float, 4> mc::Color::getValues () const"

.PP
Retrieves the RGBA values in \fCstd::array\fP 
.PP
\fBReturns:\fP
.RS 4
An array where the first element is red, the second value is green, etc 
.RE
.PP

.SS "bool mc::Color::operator!= (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 \fCColors\fP 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether the 2 \fCColors\fP don't have the same RGBA 
.RE
.PP
\fBSee also:\fP
.RS 4
operator==(Color&) const 
.RE
.PP

.SS "bool mc::Color::operator< (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 'Colors'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fCColors\fP r, g, b, and a values\&. 
.RE
.PP

.SS "bool mc::Color::operator<= (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 'Colors'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fCColors\fP r, g, b, and a values\&. 
.RE
.PP

.SS "bool mc::Color::operator== (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 \fCColors\fP 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether the 2 \fCColors\fP have the same RGBA 
.RE
.PP
\fBSee also:\fP
.RS 4
operator!=(Color&) const 
.RE
.PP

.SS "bool mc::Color::operator> (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 'Colors'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fCColors\fP r, g, b, and a values\&. 
.RE
.PP

.SS "bool mc::Color::operator>= (const \fBColor\fP & other) const"

.PP
Compares the color values of 2 'Colors'\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP Another \fC\fBColor\fP\fP object 
.RE
.PP
\fBReturns:\fP
.RS 4
The result of the operation on both \fCColors\fP r, g, b, and a values\&. 
.RE
.PP

.SS "void mc::Color::setAlpha (const \fBByte\fP & a)"

.PP
Set the alpha value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A \fCByte\fP from 0 to 255, where 255 is opaque 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetAlpha()\fP 
.PP
\fBa\fP 
.RE
.PP

.SS "void mc::Color::setBlue (const \fBByte\fP & b)"

.PP
Set the blue value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetBlue()\fP 
.PP
\fBb\fP 
.RE
.PP

.SS "void mc::Color::setGreen (const \fBByte\fP & g)"

.PP
Set the green value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIg\fP A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetGreen()\fP 
.PP
\fBg\fP 
.RE
.PP

.SS "void mc::Color::setRed (const \fBByte\fP & r)"

.PP
Set the red value of this \fC\fBColor\fP\fP from a \fCByte\fP\&. It will automatically be converted to \fCfloat\fP internally\&. 
.PP
\fBParameters:\fP
.RS 4
\fIr\fP A \fCByte\fP from 0 to 255, where 255 is the brightest 
.RE
.PP
\fBSee also:\fP
.RS 4
convertRGBAToFloat(Byte) 
.PP
\fBgetRed()\fP 
.PP
\fBr\fP 
.RE
.PP

.SS "void mc::Color::setValues (const std::array< float, 4 > & rgba)"

.PP
Sets the RGB values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. The alpha is unchanged 
.PP
\fBParameters:\fP
.RS 4
\fIrgba\fP An array where the first element is red, the second is green, etc 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<Byte,4>) 
.PP
Color(std::array<float,4>) 
.PP
Color(float,float,float,float) 
.PP
setValues(std::array<float,4>) 
.RE
.PP

.SS "void mc::Color::setValues (const std::array< float, 3 > & rgb)"

.PP
Sets the values of this \fC\fBColor\fP\fP from an array of \fCfloats\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrgb\fP An array where the first element is red, the second is green, etc 
.RE
.PP
\fBSee also:\fP
.RS 4
Color(std::array<Byte,4>) 
.PP
Color(std::array<Byte,4>) 
.PP
Color(float,float,float,float) 
.PP
setValues(std::array<float,3>) 
.RE
.PP

.SS "static float mc::Color::trimFloat (const float & color)\fC [static]\fP"

.PP
Checks the bounds of a \fCfloat\fP making sure that it is not greater than 1,0 or less than 0\&.0\&. If the inputted \fCfloat\fP is more than 1, \fC\fBtrimFloat()\fP\fP returns 1\&. 
.PP
If the inputted \fCfloat\fP is less than 0, \fC\fBtrimFloat()\fP\fP returns 0\&.
.PP
\fBParameters:\fP
.RS 4
\fIcolor\fP \fCfloat\fP to trim 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fCfloat\fP guaranteed to be between 0 and 1\&. 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "float mc::Color::a"

.PP
Definition at line 74 of file Color\&.h\&.
.SS "float mc::Color::b"

.PP
Definition at line 74 of file Color\&.h\&.
.SS "float mc::Color::g"

.PP
Definition at line 74 of file Color\&.h\&.
.SS "float mc::Color::r"

.PP
\fBColor\fP component, represented as a \fCfloat\fP\&. It is from 0\&.0 to 1\&.0, where 1\&.0 is the brightest it can get\&. 
.PP
Definition at line 74 of file Color\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
