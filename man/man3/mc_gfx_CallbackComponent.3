.TH "mc::gfx::CallbackComponent" 3 "Sat Apr 8 2017" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::gfx::CallbackComponent \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Components\&.h>\fP
.PP
Inherits \fBmc::gfx::Component\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef void(* \fBCallbackPtr\fP) (\fBEntity\fP *)"
.br
.ti -1c
.RI "typedef bool(* \fBUpdatePtr\fP) (\fBEntity\fP *)"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBsetInitCallback\fP (const \fBCallbackPtr\fP func)"
.br
.ti -1c
.RI "\fBCallbackPtr\fP \fBgetInitCallback\fP ()"
.br
.ti -1c
.RI "const \fBCallbackPtr\fP \fBgetInitCallback\fP () const "
.br
.ti -1c
.RI "void \fBsetUpdateCallback\fP (const \fBUpdatePtr\fP func)"
.br
.ti -1c
.RI "\fBUpdatePtr\fP \fBgetUpdateCallback\fP ()"
.br
.ti -1c
.RI "const \fBUpdatePtr\fP \fBgetUpdateCallback\fP () const "
.br
.ti -1c
.RI "void \fBsetRenderCallback\fP (const \fBCallbackPtr\fP func)"
.br
.ti -1c
.RI "\fBCallbackPtr\fP \fBgetRenderCallback\fP ()"
.br
.ti -1c
.RI "const \fBCallbackPtr\fP \fBgetRenderCallback\fP () const "
.br
.ti -1c
.RI "void \fBsetDestroyCallback\fP (const \fBCallbackPtr\fP func)"
.br
.ti -1c
.RI "\fBCallbackPtr\fP \fBgetDestroyCallback\fP ()"
.br
.ti -1c
.RI "const \fBCallbackPtr\fP \fBgetDestroyCallback\fP () const "
.br
.ti -1c
.RI "void \fBsetHoverCallback\fP (const \fBCallbackPtr\fP func)"
.br
.ti -1c
.RI "\fBCallbackPtr\fP \fBgetHoverCallback\fP ()"
.br
.ti -1c
.RI "const \fBCallbackPtr\fP \fBgetHoverCallback\fP () const "
.br
.ti -1c
.RI "void \fBsetCleanCallback\fP (const \fBCallbackPtr\fP func)"
.br
.ti -1c
.RI "\fBCallbackPtr\fP \fBgetCleanCallback\fP ()"
.br
.ti -1c
.RI "const \fBCallbackPtr\fP \fBgetCleanCallback\fP () const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBCallbackComponent\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBCallbackComponent\fP &other) const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBinit\fP (\fBEntity\fP *e) final"
.br
.RI "\fICalled when this \fC\fBComponent\fP\fP is added to the \fC\fBEntity\fP\fP via \fBEntity::addComponent(Component&)\fP\&. \fP"
.ti -1c
.RI "bool \fBupdate\fP (\fBEntity\fP *e) final"
.br
.RI "\fICalled when \fBEntity::update()\fP is called\&. \fP"
.ti -1c
.RI "void \fBrender\fP (\fBEntity\fP *e) final"
.br
.ti -1c
.RI "void \fBdestroy\fP (\fBEntity\fP *e) final"
.br
.RI "\fICalled when \fBEntity::destroy()\fP is called or the \fC\fBComponent\fP\fP is removed via \fBComponent::update(Entity*)\fP, whichever comes first\&. \fP"
.ti -1c
.RI "void \fBhover\fP (\fBEntity\fP *e) final"
.br
.ti -1c
.RI "void \fBclean\fP (\fBEntity\fP *e) final"
.br
.RI "\fICalled when \fBEntity::clean()\fP is called and it was dirty\&. \fP"
.ti -1c
.RI "\fBEntity\fP * \fBgetParent\fP ()"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBComponent\fP &other) const "
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBComponent\fP &other) const "
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 55 of file Components\&.h\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef void(* mc::gfx::CallbackComponent::CallbackPtr) (\fBEntity\fP *)"

.PP
Definition at line 57 of file Components\&.h\&.
.SS "typedef bool(* mc::gfx::CallbackComponent::UpdatePtr) (\fBEntity\fP *)"

.PP
Definition at line 58 of file Components\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "void mc::gfx::CallbackComponent::clean (\fBEntity\fP * e)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when \fBEntity::clean()\fP is called and it was dirty\&. This is not required for inheritance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Component\fP\&.
.SS "void mc::gfx::CallbackComponent::destroy (\fBEntity\fP * e)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when \fBEntity::destroy()\fP is called or the \fC\fBComponent\fP\fP is removed via \fBComponent::update(Entity*)\fP, whichever comes first\&. Once \fBComponent::destroy(Entity*)\fP is called, it is immediately removed from the \fC\fBEntity\fP\fP\&. Required function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Component\fP\&.
.SS "\fBCallbackPtr\fP mc::gfx::CallbackComponent::getCleanCallback ()"

.SS "const \fBCallbackPtr\fP mc::gfx::CallbackComponent::getCleanCallback () const"

.SS "\fBCallbackPtr\fP mc::gfx::CallbackComponent::getDestroyCallback ()"

.SS "const \fBCallbackPtr\fP mc::gfx::CallbackComponent::getDestroyCallback () const"

.SS "\fBCallbackPtr\fP mc::gfx::CallbackComponent::getHoverCallback ()"

.SS "const \fBCallbackPtr\fP mc::gfx::CallbackComponent::getHoverCallback () const"

.SS "\fBCallbackPtr\fP mc::gfx::CallbackComponent::getInitCallback ()"

.SS "const \fBCallbackPtr\fP mc::gfx::CallbackComponent::getInitCallback () const"

.SS "\fBEntity\fP* mc::gfx::Component::getParent ()\fC [protected]\fP, \fC [inherited]\fP"

.SS "\fBCallbackPtr\fP mc::gfx::CallbackComponent::getRenderCallback ()"

.SS "const \fBCallbackPtr\fP mc::gfx::CallbackComponent::getRenderCallback () const"

.SS "\fBUpdatePtr\fP mc::gfx::CallbackComponent::getUpdateCallback ()"

.SS "const \fBUpdatePtr\fP mc::gfx::CallbackComponent::getUpdateCallback () const"

.SS "void mc::gfx::CallbackComponent::hover (\fBEntity\fP * e)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Component\fP\&.
.SS "void mc::gfx::CallbackComponent::init (\fBEntity\fP * e)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when this \fC\fBComponent\fP\fP is added to the \fC\fBEntity\fP\fP via \fBEntity::addComponent(Component&)\fP\&. Required function\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This is not called at \fBEntity::init()\fP, instead it is called when the component is added to the \fC\fBEntity\fP\fP\&. Keep that in mind\&. 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Component\fP\&.
.SS "bool mc::gfx::CallbackComponent::operator!= (const \fBCallbackComponent\fP & other) const"

.SS "bool mc::gfx::Component::operator!= (const \fBComponent\fP & other) const\fC [protected]\fP, \fC [inherited]\fP"

.SS "bool mc::gfx::CallbackComponent::operator== (const \fBCallbackComponent\fP & other) const"

.SS "bool mc::gfx::Component::operator== (const \fBComponent\fP & other) const\fC [protected]\fP, \fC [inherited]\fP"

.SS "void mc::gfx::CallbackComponent::render (\fBEntity\fP * e)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Reimplemented from \fBmc::gfx::Component\fP\&.
.SS "void mc::gfx::CallbackComponent::setCleanCallback (const \fBCallbackPtr\fP func)"

.SS "void mc::gfx::CallbackComponent::setDestroyCallback (const \fBCallbackPtr\fP func)"

.SS "void mc::gfx::CallbackComponent::setHoverCallback (const \fBCallbackPtr\fP func)"

.SS "void mc::gfx::CallbackComponent::setInitCallback (const \fBCallbackPtr\fP func)"

.SS "void mc::gfx::CallbackComponent::setRenderCallback (const \fBCallbackPtr\fP func)"

.SS "void mc::gfx::CallbackComponent::setUpdateCallback (const \fBUpdatePtr\fP func)"

.SS "bool mc::gfx::CallbackComponent::update (\fBEntity\fP * e)\fC [final]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Called when \fBEntity::update()\fP is called\&. Required function\&. 
.PP
There is no function to remove a \fC\fBComponent\fP\fP so this is the only way for a \fC\fBComponent\fP\fP to be removed from an \fC\fBEntity\fP\fP 
.PP
\fBComponent::destroy(Entity*)\fP will be called afterwards\&. 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP The parent \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether this \fC\fBComponent\fP\fP should be deleted or not\&. 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented from \fBmc::gfx::Component\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
