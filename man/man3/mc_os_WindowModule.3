.TH "mc::os::WindowModule" 3 "Sat Apr 8 2017" "Version Alpha" "MACE" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mc::os::WindowModule \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Window\&.h>\fP
.PP
Inherits \fBmc::Module\fP, and \fBmc::gfx::Entity\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBProperties\fP : Byte { \fBVSYNC\fP = 0, \fBFULLSCREEN\fP = 1, \fBUNDECORATED\fP = 2, \fBRESIZABLE\fP = 3, \fBDESTROYED\fP = 4 }"
.br
.ti -1c
.RI "enum \fBEntityProperty\fP : Byte { \fBDEAD\fP = 0, \fBDISABLED\fP = 1, \fBINIT\fP = 2, \fBDIRTY\fP = 3, \fBMAINTAIN_X\fP = 4, \fBMAINTAIN_Y\fP = 5, \fBMAINTAIN_WIDTH\fP = 6, \fBMAINTAIN_HEIGHT\fP = 7, \fBDEFAULT_PROPERTIES\fP = 0b00000000 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBWindowModule\fP (const int width, const int height, const char *title)"
.br
.ti -1c
.RI "GLFWwindow * \fBgetGLFWWindow\fP ()"
.br
.ti -1c
.RI "const unsigned int & \fBgetFPS\fP () const "
.br
.ti -1c
.RI "void \fBsetFPS\fP (const unsigned int &FPS)"
.br
.ti -1c
.RI "void \fBcreate\fP ()"
.br
.ti -1c
.RI "const int \fBgetOriginalWidth\fP () const "
.br
.ti -1c
.RI "const int \fBgetOriginalHeight\fP () const "
.br
.ti -1c
.RI "std::string \fBgetTitle\fP ()"
.br
.ti -1c
.RI "const std::string \fBgetTitle\fP () const "
.br
.ti -1c
.RI "void \fBsetTitle\fP (const std::string &newTitle)"
.br
.ti -1c
.RI "void \fBinit\fP () override"
.br
.RI "\fICalled when \fBMACE#init\fP is called and this \fC\fBModule\fP\fP is registered\&. \fP"
.ti -1c
.RI "void \fBupdate\fP () override"
.br
.RI "\fICalled when \fBMACE#update\fP is called and this \fC\fBModule\fP\fP is registered\&. \fP"
.ti -1c
.RI "void \fBdestroy\fP () override"
.br
.RI "\fICalled when \fBMACE#destroy\fP is called and this \fC\fBModule\fP\fP is registered\&. \fP"
.ti -1c
.RI "std::string \fBgetName\fP () const  override"
.br
.RI "\fIOverride this function and return a UNIQUE name for this \fC\fBModule\fP\fP \fP"
.ti -1c
.RI "void \fBsetVSync\fP (const bool sync)"
.br
.ti -1c
.RI "bool \fBisVSync\fP () const "
.br
.ti -1c
.RI "void \fBsetFullscreen\fP (const bool full)"
.br
.ti -1c
.RI "bool \fBisFullscreen\fP () const "
.br
.ti -1c
.RI "void \fBsetResizable\fP (const bool re)"
.br
.ti -1c
.RI "bool \fBisResizable\fP () const "
.br
.ti -1c
.RI "void \fBsetUndecorated\fP (const bool un)"
.br
.ti -1c
.RI "bool \fBisUndecorated\fP () const "
.br
.ti -1c
.RI "bool \fBisDestroyed\fP () const "
.br
.ti -1c
.RI "void \fBsetCreationCallback\fP (const \fBVoidFunctionPtr\fP callback)"
.br
.ti -1c
.RI "const \fBVoidFunctionPtr\fP \fBgetCreationCallback\fP () const "
.br
.ti -1c
.RI "\fBVoidFunctionPtr\fP \fBgetCreationCallback\fP ()"
.br
.ti -1c
.RI "const std::vector< \fBEntity\fP * > & \fBgetChildren\fP () const "
.br
.RI "\fIGets all of this \fC\fBEntity\fP's\fP children\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (const \fBEntity\fP &e)"
.br
.RI "\fIRemoves a child\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (const \fBEntity\fP *e)"
.br
.RI "\fIRemoves a child\&. \fP"
.ti -1c
.RI "void \fBremoveChild\fP (\fBIndex\fP index)"
.br
.RI "\fIRemoves a child via location\&. \fP"
.ti -1c
.RI "bool \fBhasChild\fP (\fBEntity\fP &e) const "
.br
.RI "\fIChecks to see if this \fC\fBEntity\fP\fP contains an \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "void \fBclearChildren\fP ()"
.br
.RI "\fIRemoves EVERY \fC\fBEntity\fP\fP from this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "\fBEntity\fP & \fBoperator[]\fP (\fBIndex\fP i)"
.br
.RI "\fIAccess an \fC\fBEntity\fP\fP\&. \fP"
.ti -1c
.RI "const \fBEntity\fP & \fBoperator[]\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fBoperator[](Index i)\fP \fP"
.ti -1c
.RI "\fBEntity\fP & \fBgetChild\fP (\fBIndex\fP i)"
.br
.RI "\fIRetrieves a child at a certain index\&. \fP"
.ti -1c
.RI "const \fBEntity\fP & \fBgetChild\fP (\fBIndex\fP i) const "
.br
.RI "\fI\fCconst\fP version of \fBgetChild(Index)\fP \fP"
.ti -1c
.RI "int \fBindexOf\fP (const \fBEntity\fP &e) const "
.br
.RI "\fIFinds the location of an \fC\fBEntity\fP\fP in this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "bool \fBisEmpty\fP () const "
.br
.RI "\fIChecks whether this \fC\fBEntity\fP\fP has any children\&. \fP"
.ti -1c
.RI "std::vector< \fBEntity\fP * >::iterator \fBbegin\fP ()"
.br
.RI "\fIRetrieves the beginning of the children of this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "std::vector< \fBEntity\fP * >::iterator \fBend\fP ()"
.br
.RI "\fIRetrieves the end of the children of this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "\fBSize\fP \fBsize\fP () const "
.br
.RI "\fICalculates the amount of children this \fC\fBEntity\fP\fP has\&. \fP"
.ti -1c
.RI "EntityProperties & \fBgetProperties\fP ()"
.br
.RI "\fIRetrieves the \fC\fBEntity\fP's\fP properties as a \fCByteField\fP \fP"
.ti -1c
.RI "const EntityProperties & \fBgetProperties\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetProperties()\fP\fP \fP"
.ti -1c
.RI "void \fBsetProperties\fP (EntityProperties &b)"
.br
.RI "\fISet the properties for this \fC\fBEntity\fP\fP \fP"
.ti -1c
.RI "bool \fBgetProperty\fP (const \fBByte\fP position) const "
.br
.RI "\fIRetrieve the value of a property\&. \fP"
.ti -1c
.RI "void \fBsetProperty\fP (const \fBByte\fP position, const bool value)"
.br
.RI "\fISet a property to be \fCtrue\fP or \fCfalse\fP\&. \fP"
.ti -1c
.RI "\fBTransformMatrix\fP & \fBgetTransformation\fP ()"
.br
.ti -1c
.RI "const \fBTransformMatrix\fP & \fBgetTransformation\fP () const "
.br
.ti -1c
.RI "void \fBsetTransformation\fP (\fBTransformMatrix\fP &trans)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBtranslate\fP (float x, float y, float z=0\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBrotate\fP (float x, float y, float z=0\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP & \fBscale\fP (float x, float y, float z=1\&.0f)"
.br
.ti -1c
.RI "\fBEntity\fP *const \fBgetParent\fP ()"
.br
.RI "\fIRetrieve this \fCEntitys\fP parent `Entity\&. \fP"
.ti -1c
.RI "const \fBEntity\fP *const \fBgetParent\fP () const "
.br
.RI "\fI\fCconst\fP version of \fC\fBgetParent()\fP\fP \fP"
.ti -1c
.RI "bool \fBhasParent\fP () const "
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBEntity\fP &e)"
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBEntity\fP *e)"
.br
.ti -1c
.RI "void \fBaddComponent\fP (Component *action)"
.br
.ti -1c
.RI "void \fBaddComponent\fP (Component &action)"
.br
.ti -1c
.RI "std::vector< Component * > \fBgetComponents\fP ()"
.br
.ti -1c
.RI "const float & \fBgetWidth\fP () const "
.br
.ti -1c
.RI "float & \fBgetWidth\fP ()"
.br
.ti -1c
.RI "void \fBsetWidth\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetHeight\fP () const "
.br
.ti -1c
.RI "float & \fBgetHeight\fP ()"
.br
.ti -1c
.RI "void \fBsetHeight\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetDepth\fP () const "
.br
.ti -1c
.RI "float & \fBgetDepth\fP ()"
.br
.ti -1c
.RI "void \fBsetDepth\fP (const float &s)"
.br
.ti -1c
.RI "const float & \fBgetX\fP () const "
.br
.ti -1c
.RI "float & \fBgetX\fP ()"
.br
.ti -1c
.RI "void \fBsetX\fP (const float &newX)"
.br
.ti -1c
.RI "const float & \fBgetY\fP () const "
.br
.ti -1c
.RI "float & \fBgetY\fP ()"
.br
.ti -1c
.RI "void \fBsetY\fP (const float &newY)"
.br
.ti -1c
.RI "const float & \fBgetZ\fP () const "
.br
.ti -1c
.RI "float & \fBgetZ\fP ()"
.br
.ti -1c
.RI "void \fBsetZ\fP (const float &newY)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBEntity\fP &other) const  noexcept"
.br
.RI "\fICompares if 2 \fCEntities\fP have the same children, parent, and properties\&. \fP"
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBEntity\fP &other) const  noexcept"
.br
.RI "\fICompares if 2 \fCEntities\fP don't have the same children, parent, and properties\&. \fP"
.ti -1c
.RI "const \fBEntity\fP * \fBgetRoot\fP () const "
.br
.RI "\fIRetrieves the top most parent (known as the 'root\&.') \fP"
.ti -1c
.RI "\fBEntity\fP * \fBgetRoot\fP ()"
.br
.RI "\fIRetrieves the top most parent (known as the 'root\&.') \fP"
.ti -1c
.RI "\fBMetrics\fP \fBgetMetrics\fP () const "
.br
.ti -1c
.RI "void \fBreset\fP ()"
.br
.ti -1c
.RI "void \fBmakeDirty\fP ()"
.br
.RI "\fIMakes this \fC\fBEntity\fP\fP dirty and root dirty\&. \fP"
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBrender\fP ()"
.br
.RI "\fIShould be called by a \fC\fBEntity\fP\fP when the graphical \fCWindow\fP clears the frame\&. \fP"
.ti -1c
.RI "virtual void \fBhover\fP ()"
.br
.ti -1c
.RI "virtual void \fBonClean\fP ()"
.br
.ti -1c
.RI "virtual void \fBonHover\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBEntity\fP * > \fBchildren\fP = std::vector<\fBEntity\fP*>()"
.br
.RI "\fI\fCstd::vector\fP of this \fC\fBEntity\fP\\'s\fP children\&. \fP"
.ti -1c
.RI "\fBTransformMatrix\fP \fBtransformation\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBTodo\fP
.RS 4
move glfw event handling to its own thread\&.
.RE
.PP
this requires Renderer::resize(const int width, const int height) to be moved out of a callback 
.PP
Definition at line 32 of file Window\&.h\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBmc::gfx::Entity::EntityProperty\fP : \fBByte\fP\fC [inherited]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDEAD \fP\fP
Bit location representing whether an \fC\fBEntity\fP\fP is dead\&. If \fCtrue,\fP any \fBEntity\fP holding it will remove it and call \fCkill()\fP 
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(unsigned int) 
.RE
.PP

.TP
\fB\fIDISABLED \fP\fP
Property defining if an \fC\fBEntity\fP\fP can be updated and rendered\&. If this is \fCtrue\fP, \fC\fBEntity::update()\fP\fP and \fC\fBEntity::render()\fP\fP will not be called by it's parent\&. 
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(unsigned int) 
.RE
.PP

.TP
\fB\fIINIT \fP\fP
Flag representing whether an \fBEntity\fP's \fBinit()\fP function has been called\&. If \fBdestroy()\fP or \fBupdate()\fP is called and this is \fCfalse\fP, an \fCInitializationError\fP is thrown\&. 
.PP
If \fBinit()\fP is called and this is \fCtrue\fP, an \fCInitializationError\fP is thrown\&. 
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(unsigned int) 
.RE
.PP

.TP
\fB\fIDIRTY \fP\fP
Flag representing whether this \fC\fBEntity\fP\fP is dirty and it's positions needs to be recalculated\&. This will become true under the following conditions:
.IP "\(bu" 2
The \fC\fBEntity\fP\fP has been changed\&. Assume that any non-const function other than \fBrender()\fP and \fBupdate()\fP will trigger this condition\&.
.IP "\(bu" 2
The window is resized, moved, or created 
.PP
.PP
Other classes that inherit \fC\fBEntity\fP\fP can also set this to true via \fBEntity::setProperty(Byte, bool)\fP 
.PP
When an \fC\fBEntity\fP\fP becomes dirty, it will propogate up the tree\&. It's parent will become dirty, it's parent will become dirty, etc\&. This will continue until it reaches the highest level \fC\fBEntity\fP\fP, which is usually the \fCGraphicsContext\fP\&. From there, it will decide what to do based on it's \fC\fBEntity::DIRTY\fP\fP flag\&. 
.PP
Certain \fCGraphicsContexts\fP may only render when something is dirty, heavily increasing performance in applications with little moving objects\&. 
.PP
Additionally, an \fC\fBEntity\fP\fP that is considered dirty will have it's sslBuffer updated on the GPU side\&. 
.TP
\fB\fIMAINTAIN_X \fP\fP
Flag representing whether an \fBEntity\fP's X position should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_Y\fP 
.PP
\fBEntity::MAINTAIN_WIDTH\fP 
.PP
\fBEntity::MAINTAIN_HEIGHT\fP 
.RE
.PP

.TP
\fB\fIMAINTAIN_Y \fP\fP
Flag representing whether an \fBEntity\fP's Y position should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_X\fP 
.PP
\fBEntity::MAINTAIN_WIDTH\fP 
.PP
\fBEntity::MAINTAIN_HEIGHT\fP 
.PP
WindowModule::setResizable(bool) 
.RE
.PP

.TP
\fB\fIMAINTAIN_WIDTH \fP\fP
Flag representing whether an \fBEntity\fP's width should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_X\fP 
.PP
\fBEntity::MAINTAIN_Y\fP 
.PP
\fBEntity::MAINTAIN_HEIGHT\fP 
.PP
WindowModule::setResizable(bool) 
.RE
.PP

.TP
\fB\fIMAINTAIN_HEIGHT \fP\fP
Flag representing whether an \fBEntity\fP's height should be stretched when window is resized\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::MAINTAIN_X\fP 
.PP
\fBEntity::MAINTAIN_Y\fP 
.PP
\fBEntity::MAINTAIN_WIDTH\fP 
.PP
WindowModule::setResizable(bool) 
.RE
.PP

.TP
\fB\fIDEFAULT_PROPERTIES \fP\fP
.PP
Definition at line 208 of file Entity\&.h\&.
.SS "enum \fBmc::os::WindowModule::Properties\fP : \fBByte\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIVSYNC \fP\fP
.TP
\fB\fIFULLSCREEN \fP\fP
.TP
\fB\fIUNDECORATED \fP\fP
.TP
\fB\fIRESIZABLE \fP\fP
.TP
\fB\fIDESTROYED \fP\fP
.PP
Definition at line 34 of file Window\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "mc::os::WindowModule::WindowModule (const int width, const int height, const char * title)"

.SH "Member Function Documentation"
.PP 
.SS "void mc::gfx::Entity::addChild (\fBEntity\fP & e)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::addChild (\fBEntity\fP * e)\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::addComponent (\fBComponent\fP * action)\fC [inherited]\fP"

.SS "void mc::gfx::Entity::addComponent (\fBComponent\fP & action)\fC [inherited]\fP"

.PP

.SS "std::vector<\fBEntity\fP*>::iterator mc::gfx::Entity::begin ()\fC [inherited]\fP"

.PP
Retrieves the beginning of the children of this \fC\fBEntity\fP\fP 
.PP
\fBReturns:\fP
.RS 4
Pointer to the first \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::end()\fP 
.PP
\fBEntity::size()\fP 
.RE
.PP

.SS "void mc::gfx::Entity::clearChildren ()\fC [inherited]\fP"

.PP
Removes EVERY \fC\fBEntity\fP\fP from this \fC\fBEntity\fP\fP 
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.PP
\fBEntity::size()\fP 
.PP
\fBEntity::removeChild(Index)\fP 
.PP
\fBEntity::removeChild(const Entity&)\fP 
.RE
.PP

.SS "void mc::os::WindowModule::create ()"

.SS "void mc::os::WindowModule::destroy ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Called when \fBMACE#destroy\fP is called and this \fC\fBModule\fP\fP is registered\&. Use this to clear memory, close streams, or clean up anything that needs to be cleaned up\&. 
.PP
Should only be called before the program is closed\&. 
.PP
Implements \fBmc::Module\fP\&.
.SS "std::vector<\fBEntity\fP*>::iterator mc::gfx::Entity::end ()\fC [inherited]\fP"

.PP
Retrieves the end of the children of this \fC\fBEntity\fP\fP 
.PP
\fBReturns:\fP
.RS 4
End of the last \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::begin()\fP 
.PP
\fBEntity::size()\fP 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::getChild (\fBIndex\fP i)\fC [inherited]\fP"

.PP
Retrieves a child at a certain index\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Index of the \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP if \fCi\fP is less than \fC0\fP or greater than \fBsize()\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::operator[]\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "const \fBEntity\fP& mc::gfx::Entity::getChild (\fBIndex\fP i) const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fBgetChild(Index)\fP 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP \fCIndex\fP of the \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP if \fCi\fP is less than \fC0\fP or greater than \fBsize()\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::operator[]\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "const std::vector<\fBEntity\fP*>& mc::gfx::Entity::getChildren () const\fC [inherited]\fP"

.PP
Gets all of this \fC\fBEntity\fP's\fP children\&. 
.PP
\fBReturns:\fP
.RS 4
an \fCstd::vector\fP with all children of this \fC\fBEntity\fP\fP 
.RE
.PP

.SS "std::vector<Component*> mc::gfx::Entity::getComponents ()\fC [inherited]\fP"

.SS "const \fBVoidFunctionPtr\fP mc::os::WindowModule::getCreationCallback () const"

.SS "\fBVoidFunctionPtr\fP mc::os::WindowModule::getCreationCallback ()"

.SS "const float& mc::gfx::Entity::getDepth () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getDepth ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "const unsigned int& mc::os::WindowModule::getFPS () const"

.SS "GLFWwindow* mc::os::WindowModule::getGLFWWindow ()"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.SS "const float& mc::gfx::Entity::getHeight () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getHeight ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "\fBMetrics\fP mc::gfx::Entity::getMetrics () const\fC [inherited]\fP"

.SS "std::string mc::os::WindowModule::getName () const\fC [override]\fP, \fC [virtual]\fP"

.PP
Override this function and return a UNIQUE name for this \fC\fBModule\fP\fP The name for your \fC\fBModule\fP\fP is used in comparison, so make sure it is as unique as possible\&. 
.PP
It is akin to a hashcode\&. 
.PP
Implements \fBmc::Module\fP\&.
.SS "const int mc::os::WindowModule::getOriginalHeight () const"

.SS "const int mc::os::WindowModule::getOriginalWidth () const"

.SS "\fBEntity\fP* const mc::gfx::Entity::getParent ()\fC [inherited]\fP"

.PP
Retrieve this \fCEntitys\fP parent `Entity\&. \fC @return A\fP\fBEntity\fP\fCwhich contains\fPthis` 
.PP
\fBSee also:\fP
.RS 4
Entity::hasChild(const Entity&) const; 
.RE
.PP

.SS "const \fBEntity\fP* const mc::gfx::Entity::getParent () const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fC\fBgetParent()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
A \fC\fBEntity\fP\fP which contains \fCthis\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::hasChild(const Entity&) const; 
.RE
.PP

.SS "EntityProperties& mc::gfx::Entity::getProperties ()\fC [inherited]\fP"

.PP
Retrieves the \fC\fBEntity\fP's\fP properties as a \fCByteField\fP 
.PP
\fBReturns:\fP
.RS 4
The current properties belonging to this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getProperties() const\fP 
.PP
Entity::setProperties(ByteField&) 
.PP
Entity::getProperty(Index) const 
.PP
Entity::setProperty(Index, bool) 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const EntityProperties& mc::gfx::Entity::getProperties () const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fC\fBgetProperties()\fP\fP 
.PP
\fBReturns:\fP
.RS 4
The current properties belonging to this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::setProperties(ByteField&) 
.PP
Entity::getProperty(Index) const 
.PP
Entity::setProperty(Index, bool) 
.RE
.PP

.SS "bool mc::gfx::Entity::getProperty (const \fBByte\fP position) const\fC [inherited]\fP"

.PP
Retrieve the value of a property\&. By default, they are all false\&. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Location of the property based on a constant 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP or \fCfalse\fP based on the postition 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::setProperty(Index, bool) 
.PP
\fBEntity::getProperties()\fP 
.PP
Entity::setProperties(ByteField&) 
.RE
.PP

.SS "const \fBEntity\fP* mc::gfx::Entity::getRoot () const\fC [inherited]\fP"

.PP
Retrieves the top most parent (known as the 'root\&.') The root does not have any parent\&. 
.PP
If this \fC\fBEntity\fP\fP does not have any parent, returns \fCthis\fP 
.PP
\fBReturns:\fP
.RS 4
The root \fC\fBEntity\fP\fP of which this \fC\fBEntity\fP\fP belongs to\&. 
.RE
.PP

.SS "\fBEntity\fP* mc::gfx::Entity::getRoot ()\fC [inherited]\fP"

.PP
Retrieves the top most parent (known as the 'root\&.') The root does not have any parent\&. 
.PP
If this \fC\fBEntity\fP\fP does not have any parent, returns \fCthis\fP 
.PP
\fBReturns:\fP
.RS 4
The root \fC\fBEntity\fP\fP of which this \fC\fBEntity\fP\fP belongs to\&. 
.RE
.PP

.SS "std::string mc::os::WindowModule::getTitle ()"

.SS "const std::string mc::os::WindowModule::getTitle () const"

.SS "\fBTransformMatrix\fP& mc::gfx::Entity::getTransformation ()\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "const \fBTransformMatrix\fP& mc::gfx::Entity::getTransformation () const\fC [inherited]\fP"

.SS "const float& mc::gfx::Entity::getWidth () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getWidth ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "const float& mc::gfx::Entity::getX () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getX ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "const float& mc::gfx::Entity::getY () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getY ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "const float& mc::gfx::Entity::getZ () const\fC [inherited]\fP"

.SS "float& mc::gfx::Entity::getZ ()\fC [inherited]\fP"

.PP

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP
.RE
.PP

.SS "bool mc::gfx::Entity::hasChild (\fBEntity\fP & e) const\fC [inherited]\fP"

.PP
Checks to see if this \fC\fBEntity\fP\fP contains an \fC\fBEntity\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP Reference to an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCfalse\fP if this \fC\fBEntity\fP\fP doesn't contain the referenced \fC\fBEntity\fP\fP, \fCtrue\fP otherwise 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::indexOf(const Entity& ) const\fP 
.RE
.PP

.SS "bool mc::gfx::Entity::hasParent () const\fC [inherited]\fP"

.SS "virtual void mc::gfx::Entity::hover ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.SS "int mc::gfx::Entity::indexOf (const \fBEntity\fP & e) const\fC [inherited]\fP"

.PP
Finds the location of an \fC\fBEntity\fP\fP in this \fC\fBEntity\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIe\fP Reference to an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Location of \fCe,\fP or -1 if \fCe\fP is not a child of this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::operator[]\fP 
.PP
\fBEntity::getChild(Index)\fP 
.RE
.PP

.SS "void mc::os::WindowModule::init ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Called when \fBMACE#init\fP is called and this \fC\fBModule\fP\fP is registered\&. Use this to initialize variables, start streams, or launch a context\&. 
.PP
Should only be called once\&. 
.PP
Implements \fBmc::Module\fP\&.
.SS "bool mc::os::WindowModule::isDestroyed () const"

.SS "bool mc::gfx::Entity::isEmpty () const\fC [inherited]\fP"

.PP
Checks whether this \fC\fBEntity\fP\fP has any children\&. 
.PP
\fBReturns:\fP
.RS 4
If \fBEntity::size()\fP is 0 
.RE
.PP

.SS "bool mc::os::WindowModule::isFullscreen () const"

.SS "bool mc::os::WindowModule::isResizable () const"

.SS "bool mc::os::WindowModule::isUndecorated () const"

.SS "bool mc::os::WindowModule::isVSync () const"

.SS "void mc::gfx::Entity::makeDirty ()\fC [inherited]\fP"

.PP
Makes this \fC\fBEntity\fP\fP dirty and root dirty\&. Should be used over \fCsetProperty(Entity::DIRTY,true)\fP as it updaets the root parent\&. 
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getRoot()\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "virtual void mc::gfx::Entity::onClean ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::Button\fP, \fBmc::gfx::Text\fP, \fBmc::gfx::Letter\fP, \fBmc::gfx::ProgressBar\fP, and \fBmc::gfx::Image\fP\&.
.SS "virtual void mc::gfx::Entity::onHover ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP

.PP
Reimplemented in \fBmc::gfx::Button\fP\&.
.SS "bool mc::gfx::Entity::operator!= (const \fBEntity\fP & other) const\fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Compares if 2 \fCEntities\fP don't have the same children, parent, and properties\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP An \fC\fBEntity\fP\fP compare this one to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCfalse\fP if they are equal 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetProperties() const\fP 
.PP
\fBgetParent() const\fP 
.PP
\fBgetChildren() const\fP 
.PP
operator== 
.RE
.PP

.SS "bool mc::gfx::Entity::operator== (const \fBEntity\fP & other) const\fC [noexcept]\fP, \fC [inherited]\fP"

.PP
Compares if 2 \fCEntities\fP have the same children, parent, and properties\&. 
.PP
\fBParameters:\fP
.RS 4
\fIother\fP An \fC\fBEntity\fP\fP compare this one to 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if they are equal 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBgetProperties() const\fP 
.PP
\fBgetParent() const\fP 
.PP
\fBgetChildren() const\fP 
.PP
operator!= 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::operator[] (\fBIndex\fP i)\fC [inherited]\fP"

.PP
Access an \fC\fBEntity\fP\fP\&. This is different than \fC\fBgetChild()\fP\fP because \fCoperator[]\fP doesn't do bounds checking\&. Accessing an invalid location will result in a memory error\&. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Location of an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getChild(Index)\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "const \fBEntity\fP& mc::gfx::Entity::operator[] (\fBIndex\fP i) const\fC [inherited]\fP"

.PP
\fCconst\fP version of \fBoperator[](Index i)\fP 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP Location of an \fC\fBEntity\fP\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the \fC\fBEntity\fP\fP located at \fCi\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getChild(Index) const\fP 
.PP
\fBEntity::indexOf(const Entity&) const\fP 
.RE
.PP

.SS "void mc::gfx::Entity::removeChild (const \fBEntity\fP & e)\fC [inherited]\fP"

.PP
Removes a child\&. This function calls no member functions of the argument, meaning that 
.PP
\fBExceptions:\fP
.RS 4
\fIObjectNotFoundInArray\fP if this \fC\fBEntity\fP\fP does not contain the argument returns \fCfalse\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIe\fP an \fC\fBEntity\fP\fP to remove 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::removeChild(Index)\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::removeChild (const \fBEntity\fP * e)\fC [inherited]\fP"

.PP
Removes a child\&. This function calls no member functions of the argument, meaning that 
.PP
\fBExceptions:\fP
.RS 4
\fIObjectNotFoundInArray\fP if this \fC\fBEntity\fP\fP does not contain the argument returns \fCfalse\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIe\fP an \fC\fBEntity\fP\fP to remove 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::removeChild(Index)\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fINullPointerError\fP if the argument is \fCnullptr\fP 
.RE
.PP

.SS "void mc::gfx::Entity::removeChild (\fBIndex\fP index)\fC [inherited]\fP"

.PP
Removes a child via location\&. 
.PP
\fBExceptions:\fP
.RS 4
\fIIndexOutOfBounds\fP if the index is less than 0 or greater than \fBsize()\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIindex\fP Index of the \fC\fBEntity\fP\fP to be removed 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::indexOf(const Entity&) const\fP 
.PP
\fBEntity::removeChild(const Entity&)\fP 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "virtual void mc::gfx::Entity::render ()\fC [protected]\fP, \fC [virtual]\fP, \fC [inherited]\fP"

.PP
Should be called by a \fC\fBEntity\fP\fP when the graphical \fCWindow\fP clears the frame\&. Overriding this function is dangerous\&. Only do it if you know what you are doing\&. Instead, override \fC\fBonRender()\fP\fP 
.PP
\fBAttention:\fP
.RS 4
This uses an OpenGL function and must be called in a thread with an OpenGL context\&. Otherwise, an error will be thrown\&. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fIGL_INVALID_OPERATION\fP If the current thread does not have an OpenGL context 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::update()\fP 
.RE
.PP

.SS "void mc::gfx::Entity::reset ()\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::rotate (float x, float y, float z = \fC0\&.0f\fP)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::scale (float x, float y, float z = \fC1\&.0f\fP)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::os::WindowModule::setCreationCallback (const \fBVoidFunctionPtr\fP callback)"

.SS "void mc::gfx::Entity::setDepth (const float & s)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::os::WindowModule::setFPS (const unsigned int & FPS)"

.SS "void mc::os::WindowModule::setFullscreen (const bool full)"

.SS "void mc::gfx::Entity::setHeight (const float & s)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setProperties (\fBEntityProperties\fP & b)\fC [inherited]\fP"

.PP
Set the properties for this \fC\fBEntity\fP\fP 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP New \fC\fBEntity\fP\fP properties 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::getProperties()\fP 
.PP
Entity::getProperty(Index) const 
.PP
Entity::setProperty(Index, bool) 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setProperty (const \fBByte\fP position, const bool value)\fC [inherited]\fP"

.PP
Set a property to be \fCtrue\fP or \fCfalse\fP\&. By default, they are all false\&. 
.PP
\fBNote:\fP
.RS 4
Do not use \fCsetProperty(Entity::DIRTY, true)\fP\&. Use Entity::makeDity() instead\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Location of the property based on a constant 
.br
\fIvalue\fP Whether it is \fCtrue\fP or \fCfalse\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
Entity::getProperty(Index) const 
.PP
\fBEntity::getProperties()\fP 
.PP
Entity::setProperties(ByteField&) 
.RE
.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::os::WindowModule::setResizable (const bool re)"

.SS "void mc::os::WindowModule::setTitle (const std::string & newTitle)"

.SS "void mc::gfx::Entity::setTransformation (\fBTransformMatrix\fP & trans)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::os::WindowModule::setUndecorated (const bool un)"

.SS "void mc::os::WindowModule::setVSync (const bool sync)"

.SS "void mc::gfx::Entity::setWidth (const float & s)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setX (const float & newX)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setY (const float & newY)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::gfx::Entity::setZ (const float & newY)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "\fBSize\fP mc::gfx::Entity::size () const\fC [inherited]\fP"

.PP
Calculates the amount of children this \fC\fBEntity\fP\fP has\&. 
.PP
\fBReturns:\fP
.RS 4
Size of this \fC\fBEntity\fP\fP 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::isEmpty()\fP 
.RE
.PP

.SS "\fBEntity\fP& mc::gfx::Entity::translate (float x, float y, float z = \fC0\&.0f\fP)\fC [inherited]\fP"

.PP
\fBNote:\fP
.RS 4
This will make this \fC\fBEntity\fP\fP dirty\&. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBEntity::DIRTY\fP 
.RE
.PP

.SS "void mc::os::WindowModule::update ()\fC [override]\fP, \fC [virtual]\fP"

.PP
Called when \fBMACE#update\fP is called and this \fC\fBModule\fP\fP is registered\&. Use this update states, send messages, swap graphics buffers, render, process, or anything that needs to be periodically checked\&. 
.PP
Implements \fBmc::Module\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::vector<\fBEntity\fP*> mc::gfx::Entity::children = std::vector<\fBEntity\fP*>()\fC [protected]\fP, \fC [inherited]\fP"

.PP
\fCstd::vector\fP of this \fC\fBEntity\fP\\'s\fP children\&. Use of this variable directly is unrecommended\&. Use \fC\fBaddChild()\fP\fP or \fC\fBremoveChild()\fP\fP instead\&. 
.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.PP
Definition at line 751 of file Entity\&.h\&.
.SS "\fBTransformMatrix\fP mc::gfx::Entity::transformation\fC [protected]\fP, \fC [inherited]\fP"

.PP
\fBWarning:\fP
.RS 4
This should only be used internally or by advanced users\&. Misuse can cause undefined behavior 
.RE
.PP

.PP
Definition at line 756 of file Entity\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for MACE from the source code\&.
